<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>方莲 | William</title>
 <link href="http://williamlfang.github.com/cn/" rel="self"/>
 <link href="http://williamlfang.github.com/cn"/>
 <updated>2014-03-14T01:35:26+08:00</updated>
 <id>http://williamlfang.github.com/cn</id>
 <author>
   <name>william</name>
   <email>william.lian.fang@gmail.com</email>
 </author>

 
 <entry>
   <title>不甘心的这辈子</title>
   <link href="http://williamlfang.github.com/cn/2014/03/14/bu-gan-xin-de-zhe-bei-zi/"/>
   <updated>2014-03-14T00:00:00+08:00</updated>
   <id>http://williamlfang.github.com/cn/2014/03/14/bu-gan-xin-de-zhe-bei-zi</id>
   <content type="html">&lt;p&gt;我有一个朋友，虽然不怎么见面，也不常常往来，只是偶尔的通着电话，聊聊一些无关痛痒的话题。毕竟，我们都有自己的生活与世界，也活在不同的时光里，却每回有过联系，都是彼此相互诉说与倾听。他有他的故事，也许平时不愿让人知晓他坚强背后的忧伤，兴许对某个女生长期稚气般却执着的感情，他都会在电话那头自顾自己的说着，天涯海角的，他此时像是一个手持油笔的画家，恣意盎然的描述那个属于自己的星空。而我，只是静默的聆听着这样的诉说。&lt;/p&gt;

&lt;p&gt;因为我知道，更多时候，我也是线端那头的他，变化的只是手里的那只画笔从深灰色到暗蓝色。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;我不知道这样的同化保持了多少年的光阴，也许是从他离开高中之后。后来渐渐失去音讯，却有在我大学的某个晚上，出乎意料却时常期盼地接到他从北方的北方给我拨打的一通电话。话音那头，我甚至分不清逝去的时光去向那里，我们仿佛依旧是年少，依旧有许多的话，彼此不去理解，只是聆听着。&lt;/p&gt;

&lt;p&gt;这样的时候，只是偶尔，却也温馨。&lt;/p&gt;

&lt;p&gt;我的大学四年里，常常被各种针管困扰着，被各种不理想的血糖测值烦扰。那时候，我也想象一个健康而完全的少年在绿茵场奔跑的样子，想象在广袤的原野间如风极驰，没有任何的羁绊与束缚。我想我上辈子是风，下辈子是雨，那么这辈子我最好还是安分些。也就是在这样的四年里，我的朋友，他从远方拨打的一通通电话，给了我自由舒展的想象空间，给了我任自挥舞的浓墨笔尖，得意在我这张空白的即将清零的人生里，尽情的多写了几个字符，多绘了一丁点的颜色，以至于在这个北方昏暗的阴霾天里，得意看多一点希望。多少年后，我一直去努力回忆那些夜晚里到达的电话铃声，嘀嘀嘀嘀，声音缓缓却催促，低沉却是在这个无情的黑暗里照见最远方向的灯火，我也试图靠着这仅有的一点过去，伴我走完余下的路程。&lt;/p&gt;

&lt;p&gt;来到厦门后，我的心情有了好转，再加上平时有到环岛路去慢跑，血糖水平得到了一定的控制。这样得意忘形的日子里，我却逐渐忘却了我那个可爱的朋友，还有他低沉的嗓音。我们比往日的偶尔更加偶尔的联系着，不高不低不急不慢，缓缓的如同巴赫的曲子，在夜间的小溪边叮咚的流淌，有时像是夏夜的虫鸣，各自吱了一声，便匆匆的收起赶场的伙计，各自回家。&lt;/p&gt;

&lt;p&gt;直到有一天，我试着再像一只远走的老马循着旧日时光的足迹，不急不慢的敲打那几个熟悉的数字按钮，却等到了无穷无尽的等待。话线的那端，像是一个迷路的孩子，在外面的世界兴冲冲的玩耍了整天，却突然找不到回家的路，悄悄躲在某个幽暗的角落独自啜泣，音调时慢时快，却是同样的曲调不急不慢。我却殊不知，这个流浪的孩子，真的迷失在黑森林的暗道里，走不出来，找不到回家的路了。&lt;/p&gt;

&lt;p&gt;我以前跟他说，我常常抱怨这辈子为病痛说折磨，堂堂男儿身，却被这样的无情的病魔捆绑在这无用而尽费热量的躯干里面。我这不甘心的一辈子。还有很多的事，已经不能完成的，没能想要完成的，还有来不及完成。&lt;/p&gt;

&lt;p&gt;我的朋友，他还有很多事情没有完成的，却真的不能完成了。&lt;/p&gt;

&lt;p&gt;我这不甘心的一辈子，已经在过去结束了。&lt;/p&gt;

<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></content>
 </entry>
 
 <entry>
   <title>诸多事情</title>
   <link href="http://williamlfang.github.com/cn/2014/02/12/zhu-duo-shi-qing/"/>
   <updated>2014-02-12T00:00:00+08:00</updated>
   <id>http://williamlfang.github.com/cn/2014/02/12/zhu-duo-shi-qing</id>
   <content type="html">&lt;p&gt;想着有一段时间没有码字了，指尖竟然有些生疏。其实每次打开笔记本，总是想着要有千言万语诉说，那种浓厚的情绪像是一次乘坐列车的远行去拜见一位老友，漫长的路途上早就打好了腹稿构造了完整的画面，可是真正见面了，我们却什么也不说，只是静静的凝望彼此，一言不发。我是有着千般感情万种思绪，却像是失去了老友多年消息总是联系不上了，我愈要赴会，却不知该买到何站的列车。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;此情可待成追忆，只是当时已惘然。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- more --&gt;

&lt;h2 id=&quot;section&quot;&gt;一场团圆的春节&lt;/h2&gt;

&lt;p&gt;这个春节过得平淡，安静的出奇。本来嘛，厦门就是一个旅游的城市，人来人往，车水马龙，热闹喧嚣，浮华尘世，这个本该就是这座城市的标志。可是真正到了春节，却也少了人，不见了往日的喧嚣。这座城市一下子变得可爱，如含蓄的姑娘，像待放的花苞，羞羞答答的。大抵是政府的规定只为贪图省事（baoli zhifa），我们的城市在春节期间竟然不允许燃放烟花。只是冷冷清清的城市，在这个孤孤单单的季节里，多少显得有点委屈。&lt;/p&gt;

&lt;p&gt;不过几日的天气倒是也好。阳光灿烂如孩童的笑脸天真无瑕，暖心的却不热烈，滑落在皮肤生怕破碎。有一天猪头提议全家动身前去东坪山晒太阳，只为了这一刻的阳光弥足珍贵。是啊，往前每每在老家过年，春节这几天几乎都是阴雨连天，难得的出现这么晴朗的天气。南方的小渔村更添了几分冷意，空气了充斥了水气的冰冻，像是凝结的薄幕。更有那些象征喜庆的鞭炮在燃放过后四处挥舞的烟雾，掺杂在冰晶的半空，久久不散，犹如仙境。一个人常年在外旅居，此刻见了这般景象，竟有一些感伤，仿佛这是一股催泪剂，流浪的酸楚与归家的喜悦一齐涌上眼角，润湿了眼眶。&lt;/p&gt;

&lt;p&gt;今天春节并没有回老家过春节。年前和猪头商量了一下，决定邀请家中两位老人来厦团聚。一来是我们也没有那么多时间，本来她的假期就少得可怜，这来来回回的在路上费的时间多，也够折腾人（航班经常改道，火车时而晚点），小咪豆也不大适合舟车劳顿，怕了出了漏子；二来，我们也想让老人家出来走走，毕竟厦门这个春节的天气真的是好的惹人疼爱，招人喜欢，而且在这边我们两个都比较熟悉，平时出来旅游吃饭都挺方便的。于是乎，我们家今年便最终在厦门团聚了。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;一次未行的聚会&lt;/h2&gt;

&lt;p&gt;掐指一算，现在离初中毕业已经十年了。十年可算是一个大时期，我从一个毛头小伙子到一个丈夫与一个孩子的父亲。走过的这十年，一直都坎坎坷坷，曲曲折折。人生本当如此，历经风雨，奋斗不止，在晚年回首方有可念之处。可是这十年来，我总是那么的羡慕当初的那个纯真的孩子，一脸惘然的朝向未知的旅途，却也满心的勇气。&lt;/p&gt;

&lt;p&gt;初中的校园坐落在一个海滩湾处。小，而且年代久远，当时又正值人口峰值，我们的学校里竟然漫漫的都是人。这业已脱离了我对学校的概念，原先的小学人少，地大，小伙伴们总是有各种玩趣之地可去。可是现在，我只能在教室里待着，不能出去，稍不小心，便有人在走廊里撞到了。在这个拥挤甚至可以说是臃肿的校园里，我却感到无尽的孤单。人与人的会面，往往加深了心与心的分裂。愈多的人，愈感孤单。这种在人多之处说体会到的孤单，长年累月的陪伴着我，阴魂不散，挥之不去。&lt;/p&gt;

&lt;p&gt;初中唯一让我着迷的事情，是数学课本里那些由符号与方程编写而成的美丽世界。它们像极了天际线在昏黄夜晚的轮廓，淡淡的泛着氤氲。很多时候，我愿凝视这个虚无缥缈却深埋心底的幻城，痴痴的美梦着，想要得到那个神秘的答案。&lt;/p&gt;

&lt;p&gt;无数的小时里，我把自己深埋在那些符号里，不吭一声。我的这种孤傲与孤单，将周边的同学都隔离起来了，不再联系。其实，我只是不说一句话；其实，我只是一直都孤单着。&lt;/p&gt;

&lt;p&gt;很多的年头里，我不曾与我的那些小伙伴们联络。&lt;/p&gt;

&lt;p&gt;今年突然听娜姐给我电话（我也不知她何来家里的号码），说是春节会有同学聚会，毕竟许多人已经不见整十年，希望此次可以相聚会面。可是，这次命运又在捉弄玩笑，今年正值全家都齐来厦门团聚，并没有计划会老家。而家中尚有小咪豆需要照顾，故而此次聚会也无奈不能成行。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;一个未果的问题&lt;/h2&gt;

&lt;p&gt;有一个悬而未解的问题，未果，不便诉说。&lt;/p&gt;

<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></content>
 </entry>
 
 <entry>
   <title>美联储的「博士系」</title>
   <link href="http://williamlfang.github.com/cn/2014/02/12/mei-lian-chu-de-bo-shi-xi/"/>
   <updated>2014-02-12T00:00:00+08:00</updated>
   <id>http://williamlfang.github.com/cn/2014/02/12/mei-lian-chu-de-bo-shi-xi</id>
   <content type="html">&lt;p&gt;下午在浏览『华尔街见闻』的时候正好看到了这样一篇有意思的文章，大致介绍了美联储是如何从一个由实干家（如银行家与金融巨头）组成的俱乐部升级成由一帮&lt;a href=&quot;http://wallstreetcn.com/node/75851&quot;&gt;经济学博士引领的「学院派」&lt;/a&gt;。文章写的条理比较清楚的了，从成员的学位背景出发梳理了美联储的发展历程。诸位如果感兴趣可以前去看看。我这里主要是提供一个个人的随想而已。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;首先来一个「全家福」吧。
&lt;a href=&quot;/cn/assets/images/r-figures/2014-02-12-mei-lian-chu-de-bo-shi-xi/fed.jpg&quot;&gt;&lt;img src=&quot;/cn/assets/images/r-figures/2014-02-12-mei-lian-chu-de-bo-shi-xi/fed.jpg&quot; alt=&quot;the fed&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文章谈到了对美联储决策有重要影响的几位「高官」的学历背景。目前新晋美联储主席的耶伦（Yellen）拥有 Yale 经济学博士学历，其在学术界有颇有建树。而那些身处高职的几位委员会成员（&lt;strong&gt;FOMC&lt;/strong&gt;）均配有经济学博士学位，如 Stanley Fischer 就是前 &lt;strong&gt;IMF&lt;/strong&gt; 的首席经济学家 [^1] 。而如果从历史的纵向来看，这个趋势就更加明显了：沃尔克当时还只是经济学硕士，到了格林斯潘后来获得博士学位，而前任伯南克就已经是一名正式的大学（宏观）经济学教授了。Blinder 是原 &lt;strong&gt;FOMC&lt;/strong&gt; 委员，他对 &lt;strong&gt;Fed&lt;/strong&gt; 的历史颇有研究，宣称：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我相信，当时在美联储80年的历史中，我是第四个或第五个学院派委员。不久后耶伦也来了，然后学院派就开始蜂拥而入。如今，这是一个很正常的现象，而且学院派教授更受欢迎。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;中国有古语说『物以类聚，人以群分』，这个自然界的普遍真理同样适用于经济学界。我们经常看到持有不同观点的学派之间是如何明争暗斗的，比如早些年的世纪大战——凯恩斯与哈耶克的论战，到后来由弗里德曼扛旗的货币主义学派反攻凯恩斯主义阵营。有些时候我真就觉得经济学这个大火锅里搅拌的是娱乐圈的废料，「你方唱罢我来和」，不无热闹，却全无一点增进人民福祉的实景。&lt;/p&gt;

&lt;p&gt;当初成立美联储的初衷是为了结束美国国内混乱的金融秩序，统一由一个中央决策机构来制定、执行货币政策。因此，当初在位掌权的一般都是一些银行家与金融巨头，大家都比较注重实干，以直觉和经验取胜，很少能寻觅到经济学院派的作风。&lt;/p&gt;

&lt;p&gt;物是人非，斗转星移，我们现在看到美联储的境况，清一色的由理论界与学院派占山为王，并且在将来的很长一段时间内，这样的趋势会进一步明显。这些成员一般都具有良好的经济学训练，取得正规的博士学位，而且绝大部分还有过学术研究的经历，在各自的领域都有不小的影响力。如前任伯南克，在研究经济萧条理论、商业周期、宏观经济与失业率等诸多方面颇有成就。下面这幅图揭示了在美联储长达一个世纪的演变过程中，成员学术能力的提升。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/cn/assets/images/r-figures/2014-02-12-mei-lian-chu-de-bo-shi-xi/position.jpg&quot; alt=&quot;position&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就美联储成员在学位背景上不断更新的情况来分析，文章是这样认为的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;美联储拥有越来越多的博士可能是件好事。一个只有经济学博士担任高级职位的美联储将有很多局限。多元化会带来各种正面效应，单一文化则会脆弱和不健康。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我的想法是，今后金融实务界能够更好的预测到美联储的决策机制了。在以前，美联储在公开市场的决策与操作动机基本是一个黑盒子，外界无从知晓。到了上世纪70年代，美联储才开始注重与大众的沟通，定期的发布公告向金融市场传送消息，并且在独立性方面获得了巨大的改善。可是外界在对美联储的决策进行拿捏把握上依然小心谨慎，如履薄冰。这归根到底还是因为美联储的决策机制不够开放，无法面向外界提供所有的内部信息。而正是这种信息上的不对称，导致每次在美联储闭门研讨经济决策的前后时期均可看到明显的市场波动，伤害经济的稳健。&lt;/p&gt;

&lt;p&gt;而现在，我们可以从美联储成员的组成结构上获得一定的「启发」。不同的经济学理论在针对同样一个经济问题时提供的解决方案千差万别，有时甚至是南辕北辙，背道而驰。因此，我们可以借助对美联储组成成员的经济理论主张上分析其未来的决策风格与指导理论，从而在一定程度上透析美联储这个神秘的机构。我的建议时，当前的市场参与者还是需要对新一届的美联储决策机构多做一些「功课」，以便深入了解其决策特征，从而更好的预测与把握美联储在今后制定的各项经济政策。&lt;/p&gt;

&lt;p&gt;当然，我们也可以从另外一个方面看问题。就是如果美联储的成员构成正的过于学院派，那么其在应对更加具体的金融事件上，可能不会从金融实务界的形势出发，或者干脆就忽视了那些真正需要解决问题的方案的银行家的呼声。这对美联储今后的决策有效性不得不大打折扣，甚至在某些时候反而会伤害实际经济的健康发展。纯粹由经济理论模型提出的药方往往不能够良好的「接地气」，反而挫伤实体经济的积极性。&lt;/p&gt;

&lt;p&gt;[^1] Fischer 也是学术界的大牛，和 Blanchard 共同著有“Lectures on Macroeconomcis”，红极一时，可谓那个时代的标准 &lt;em&gt;textbook&lt;/em&gt;。&lt;/p&gt;

<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></content>
 </entry>
 
 <entry>
   <title>Data Structure</title>
   <link href="http://williamlfang.github.com/cn/2014/01/26/data-structure/"/>
   <updated>2014-01-26T00:00:00+08:00</updated>
   <id>http://williamlfang.github.com/cn/2014/01/26/data-structure</id>
   <content type="html">&lt;p&gt;这一章主要介绍了在 &lt;strong&gt;R&lt;/strong&gt; 中最基本的元素：数据。前段时间我在网上看到一个帖子（暂时忘记在哪里找到了），强调「data science」的重心不是在前面的那个「data」，而是后面的「science」。这是因为随着互联网的深入发展，我们现在不再是缺乏数据，反而是面临着「big data」造成的「information rich」（信息冗余）的困扰。因此，今后的数据科学应当更进一步的发展新的理论与方法来解决大数据分析。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;好了，这个扯远了。不过在 &lt;strong&gt;R&lt;/strong&gt; 中，我们最紧要的事情就是：给了一大箩筐的数据，可能是排列完整的，不过大多数情况下是混乱不堪的，要求对这些数据做统计分析与可视化工作。这个基本上是一件既头疼又心烦的苦差事。首先的任务是，先对这些数据做一定格局的处理，得到我们后续需要使用的信息变量。因此，熟练掌握处理数据的基本方法，对未来的分析至关重要。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;概览&lt;/h2&gt;

&lt;p&gt;Wickham 用一张表格总结了 &lt;strong&gt;R&lt;/strong&gt; 中的数据结构&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;R’s base data structures are summarised in the table below, organised by their dimensionality and whether they’re homogeneous (all contents must be of the same type) or heterogeneous (the contents can be of different types):&lt;/p&gt;

  &lt;table&gt;
    &lt;thead&gt;
      &lt;tr&gt;
        &lt;th&gt; &lt;/th&gt;
        &lt;th&gt;Homogeneous&lt;/th&gt;
        &lt;th&gt;Heterogeneous&lt;/th&gt;
      &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;1d&lt;/td&gt;
        &lt;td&gt;Atomic vector&lt;/td&gt;
        &lt;td&gt;List&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;2d&lt;/td&gt;
        &lt;td&gt;Matrix&lt;/td&gt;
        &lt;td&gt;Data frame&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td&gt;nd&lt;/td&gt;
        &lt;td&gt;Array&lt;/td&gt;
        &lt;td&gt; &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;p&gt;需要解释的是标量（scalar）。什么是标量呢？就是一个个单独的变量，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- 5
y &amp;lt;- &quot;scalar&quot;

x

## [1] 5

y

## [1] &quot;scalar&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;R&lt;/strong&gt; 默认地将标量识别为 1*1 的向量（vector），也就是 0-dimensional。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里科普一下有关 &lt;strong&gt;R&lt;/strong&gt; 中的面向对象的特征。也就是说， &lt;strong&gt;R&lt;/strong&gt; 中所有的元素都可以叫做「对象」（obgect），这不仅仅是基本的数据，如向量、data frame，还包括函数（function）、环境（environment），甚至是符号（symbols）。 &lt;strong&gt;R&lt;/strong&gt; 处理完分析后得到的就是一个对象，我们需要哪儿元素，直接提取就可以了。比如，&lt;/p&gt;

&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    df = data.frame(x = rnorm(100, 0, 1), y = seq(from = 1, to = 100))
    result &amp;lt;- lm(y ~ x, data = df)
    
    result

    ## 
    ## Call:
    ## lm(formula = y ~ x, data = df)
    ## 
    ## Coefficients:
    ## (Intercept)            x  
    ##       51.01         3.01
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;得到的结果存储在 &lt;code&gt;result&lt;/code&gt; 里，这个就是一个对象，等到我们需要使用其中的「子对象」时，再从中提取即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    result$coeff

    ## (Intercept)           x 
    ##      51.005       3.007
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;面向对象的编程能够提供非常灵活的数据处理结果，并且具有较高的程序维护性。这在 &lt;strong&gt;R&lt;/strong&gt; 得到了极大的展现。&lt;/p&gt;

&lt;h3 id=&quot;str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;：查看数据结构&lt;/h3&gt;
&lt;p&gt;查看数据类型可以使用命令 &lt;code&gt;str()&lt;/code&gt; &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;str(df)

## 'data.frame':	100 obs. of  2 variables:
##  $ x: num  0.659 0.277 0.614 -0.655 -0.896 ...
##  $ y: int  1 2 3 4 5 6 7 8 9 10 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;向量&lt;/h2&gt;

&lt;p&gt;如上所述， &lt;strong&gt;R&lt;/strong&gt; 中主要的一维数据类型包括 &lt;code&gt;atomic vector&lt;/code&gt;（基础向量） 和 &lt;code&gt;list&lt;/code&gt;（列表），前者要求罗列其中的数据均是同属性的，比如 &lt;code&gt;logical&lt;/code&gt;，&lt;code&gt;interger&lt;/code&gt;，&lt;code&gt;double&lt;/code&gt;，和 &lt;code&gt;character&lt;/code&gt;。而后者 &lt;code&gt;list&lt;/code&gt; 则可以是多种数据类型的混合。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;基础向量&lt;/h3&gt;

&lt;p&gt;基础向量是组成 &lt;strong&gt;R&lt;/strong&gt; 编程语言的基石，可以由此构成其他类型的数据结构。怎么去理解  &lt;strong&gt;R&lt;/strong&gt; 中的向量呢？&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;数据的向量化&lt;/h4&gt;

&lt;p&gt;其实，这个可以看作是一个研究变量的序列观测值。比如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- c(35.6, 36.1, 35.8, 37, 36.5, 37.2, 35.8)
str(x)

##  num [1:7] 35.6 36.1 35.8 37 36.5 37.2 35.8

is.vector(x)

## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个就是一个向量，可以视为一天中在七个不同时间段的气温观测。因此，我们可以利用这个向量来产生矩阵，从而实现多元变量在不同时间序列上的观测值。其实，这种数据的向量化不仅提供了对数据的直观理解，而且还能提高 &lt;strong&gt;R&lt;/strong&gt; 的运算速度，尽量避免使用循环，优化程序。这点我们在日后会继续讨论。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;生成向量的方法&lt;/h4&gt;

&lt;p&gt;用于生成向量的命令主要有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;c()&lt;/code&gt;:即「concantinate」的意思，用于生成一个向量，并且可用于嵌套&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  a &amp;lt;- c(1, 2, 4, 6, 8)
  b &amp;lt;- c(1, c(2, c(4, 6.8)))  # 套嵌使用
  a == b

  ## Warning: longer object length is not a multiple of shorter object length

  ## [1]  TRUE  TRUE  TRUE FALSE FALSE

    
  s &amp;lt;- c(1:10)  # 一个序列。相当于 seq(from = 1, to = 10, by= 1)
  s

  ##  [1]  1  2  3  4  5  6  7  8  9 10

    
  int &amp;lt;- c(1L, 6L, 8L)  # 产生integer类
    
  log &amp;lt;- c(T, F, F, T, T)  # logical
    
  chr &amp;lt;- c(&quot;these&quot;, &quot;are&quot;, &quot;some&quot;, &quot;character&quot;)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;seq()&lt;/code&gt;:即「sequence」的意思，主要用于产生一个带有规律的序列        &lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  f &amp;lt;- seq(1:10)  # 默认的increament是1,相当于 c(1:10)
  f

  ##  [1]  1  2  3  4  5  6  7  8  9 10

    
  g &amp;lt;- seq(from = 1, to = 10, by = 0.5)
    
  g

  ##  [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5
  ## [15]  8.0  8.5  9.0  9.5 10.0
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;rep()&lt;/code&gt;:即[replecate],重复某个数或者某个「序列」，可用于产生较为复杂的数据。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  h &amp;lt;- rep(5, 10)  # 单个数字的重复
  h

  ##  [1] 5 5 5 5 5 5 5 5 5 5

    
  j &amp;lt;- rep(c(1:3), 3)  # 重复一个序列 c(1:3)
  j

  ## [1] 1 2 3 1 2 3 1 2 3
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;rnorm()&lt;/code&gt;:产生随机数，还有其他的分布&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  k &amp;lt;- rnorm(100)  #default：rnorm(no, mean = 0, sd = 1)
    
  l &amp;lt;- rnorm(100, mean = 2, sd = 5)
  plot(density(l))
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;img src=&quot;/cn/assets/images/r-figures/2014-01-26-data-structure/unnamed-chunk-9.png&quot; alt=&quot;plot of chunk unnamed-chunk-9&quot; /&gt; &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-5&quot;&gt;类型与长度&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;typeof()&lt;/code&gt; 用于查看数据类型，而 &lt;code&gt;length()&lt;/code&gt; 则用于查看向量长度：如果是一维数据，则给出长度；如果是矩阵或者 &lt;code&gt;data.frame&lt;/code&gt;，则给出 &lt;code&gt;nrow&lt;/code&gt; 与 &lt;code&gt;ncol&lt;/code&gt; 的合计。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- rnorm(100)
typeof(x)

## [1] &quot;double&quot;

length(x)

## [1] 100


y &amp;lt;- c(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;)
typeof(y)

## [1] &quot;character&quot;

length(y)

## [1] 3


z &amp;lt;- c(T, T, F)
typeof(z)

## [1] &quot;logical&quot;

length(z)

## [1] 3


w &amp;lt;- seq(from = 1, to = 10, by = 1)
typeof(w)

## [1] &quot;double&quot;

length(w)

## [1] 10


mat &amp;lt;- matrix(rnorm(20), nrow = 4, ncol = 5)
typeof(mat)

## [1] &quot;double&quot;

length(mat)

## [1] 20
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;list&quot;&gt;&lt;code&gt;list&lt;/code&gt;:列表&lt;/h3&gt;

&lt;p&gt;我们已经知道，&lt;code&gt;vector&lt;/code&gt;是用于同种类型属性的数据，而&lt;code&gt;list&lt;/code&gt;则适用于不同类型的数据，可以说是各种数据的一个「大火锅」。我们使用&lt;code&gt;list()&lt;/code&gt;来生成数据，不是之前介绍的&lt;code&gt;c()&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;u &amp;lt;- list(1:3, &quot;cha&quot;, T, F, c(1, 4, 7), rep(1, 3), seq(1:5))

u

## [[1]]
## [1] 1 2 3
## 
## [[2]]
## [1] &quot;cha&quot;
## 
## [[3]]
## [1] TRUE
## 
## [[4]]
## [1] FALSE
## 
## [[5]]
## [1] 1 4 7
## 
## [[6]]
## [1] 1 1 1
## 
## [[7]]
## [1] 1 2 3 4 5

str(u)

## List of 7
##  $ : int [1:3] 1 2 3
##  $ : chr &quot;cha&quot;
##  $ : logi TRUE
##  $ : logi FALSE
##  $ : num [1:3] 1 4 7
##  $ : num [1:3] 1 1 1
##  $ : int [1:5] 1 2 3 4 5

typeof(u)

## [1] &quot;list&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，&lt;code&gt;list&lt;/code&gt;也可以跟&lt;code&gt;c()&lt;/code&gt;一样实现套嵌 (Wickham称之为[recursive])&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;v &amp;lt;- list(list(2, 4, T, &quot;nope&quot;, seq(4:8)), rep(3:4, 2), list(T, F, &quot;yes&quot;))
v

## [[1]]
## [[1]][[1]]
## [1] 2
## 
## [[1]][[2]]
## [1] 4
## 
## [[1]][[3]]
## [1] TRUE
## 
## [[1]][[4]]
## [1] &quot;nope&quot;
## 
## [[1]][[5]]
## [1] 1 2 3 4 5
## 
## 
## [[2]]
## [1] 3 4 3 4
## 
## [[3]]
## [[3]][[1]]
## [1] TRUE
## 
## [[3]][[2]]
## [1] FALSE
## 
## [[3]][[3]]
## [1] &quot;yes&quot;


str(v)

## List of 3
##  $ :List of 5
##   ..$ : num 2
##   ..$ : num 4
##   ..$ : logi TRUE
##   ..$ : chr &quot;nope&quot;
##   ..$ : int [1:5] 1 2 3 4 5
##  $ : int [1:4] 3 4 3 4
##  $ :List of 3
##   ..$ : logi TRUE
##   ..$ : logi FALSE
##   ..$ : chr &quot;yes&quot;

typeof(v)

## [1] &quot;list&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;factors&quot;&gt;factors:因子&lt;/h3&gt;

&lt;p&gt;因子也是一种向量类型，不过在因子里面，我们需要预先设定好水平值。换句话说，因子有两个属性特者&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;class（类型)：也就是 &lt;code&gt;factor&lt;/code&gt;，使用命令 &lt;code&gt;class()&lt;/code&gt; 来查看。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;level (层级)：表明因子有哪些不同取值。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;x &amp;lt;- factor(c(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;))
x
  
## [1] a b b a
## Levels: a b
  
class(x)
  
## [1] &quot;factor&quot;
  
levels(x)
  
## [1] &quot;a&quot; &quot;b&quot;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;矩阵&lt;/h2&gt;

&lt;p&gt;前面我们解释过如何看待向量（vector）作为一个研究变量的观测，那么，一个有多祖向量组成的矩阵（&lt;strong&gt;Matrix&lt;/strong&gt;）就可以被视为是一个多元变量的观测。每一个列向量表示一个变量，而每一个行向量则表示一次的观测结果。这样，我们便可以将其与多元统计结合在一起理解了。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;创建矩阵&lt;/h3&gt;

&lt;p&gt;由于矩阵是一个带有二维属性的数据列表，我们在创建矩阵时需要设定矩阵的行与列数目。表示矩阵列向量数据的是命令 &lt;code&gt;ncol&lt;/code&gt;, 相应的，行数目的是 &lt;code&gt;nrow&lt;/code&gt;。具体的方法有&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;预先设定好行列数：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mat01 &amp;lt;- matrix(1:10, ncol = 2, nrow = 5)
   
 mat01
   
 ##      [,1] [,2]
 ## [1,]    1    6
 ## [2,]    2    7
 ## [3,]    3    8
 ## [4,]    4    9
 ## [5,]    5   10
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用命令 &lt;code&gt;dim()&lt;/code&gt; 设置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mat02 &amp;lt;- matrix(1:10)
 dim &amp;lt;- c(2, 5)
   
 mat02
   
 ##       [,1]
 ##  [1,]    1
 ##  [2,]    2
 ##  [3,]    3
 ##  [4,]    4
 ##  [5,]    5
 ##  [6,]    6
 ##  [7,]    7
 ##  [8,]    8
 ##  [9,]    9
 ## [10,]   10
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-8&quot;&gt;矩阵的行列名称&lt;/h3&gt;

&lt;p&gt;有时候，我们需要指定矩阵当中的行列名称，就像在 &lt;strong&gt;Excel&lt;/strong&gt; 里面有表头一样。这样可以通过命令来完成&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;colnames&lt;/code&gt;：列名称。可以看作是不同的研究变量，比如在多元回归里面的不同影响因素。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mat03 &amp;lt;- matrix(1:15, ncol = 3, nrow = 5)
   
 mat03
   
 ##      [,1] [,2] [,3]
 ## [1,]    1    6   11
 ## [2,]    2    7   12
 ## [3,]    3    8   13
 ## [4,]    4    9   14
 ## [5,]    5   10   15
   
   
 colnames(mat03) &amp;lt;- c(&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;)  # 三个研究变量
   
 mat03
   
 ##      x1 x2 x3
 ## [1,]  1  6 11
 ## [2,]  2  7 12
 ## [3,]  3  8 13
 ## [4,]  4  9 14
 ## [5,]  5 10 15
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;rownams&lt;/code&gt;：行名称，算作一次的截面数据。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mat04 &amp;lt;- matrix(1:15, ncol = 5, nrow = 3)
   
 mat04
   
 ##      [,1] [,2] [,3] [,4] [,5]
 ## [1,]    1    4    7   10   13
 ## [2,]    2    5    8   11   14
 ## [3,]    3    6    9   12   15
   
   
 rownames(mat04) &amp;lt;- c(&quot;obs01&quot;, &quot;obs02&quot;, &quot;obs03&quot;)
   
 mat04
   
 ##       [,1] [,2] [,3] [,4] [,5]
 ## obs01    1    4    7   10   13
 ## obs02    2    5    8   11   14
 ## obs03    3    6    9   12   15
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;data-frames&quot;&gt;Data Frames：数据框&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Data Frame&lt;/strong&gt; 可以说是 &lt;strong&gt;R&lt;/strong&gt; 中最重要的数据类型了，一方面，既具有向量的特征，表示同样长度的变量数据，另一方面，还保持了 &lt;code&gt;list&lt;/code&gt; 中对不同类型数据的支持。这个也是我们做计量经济分析主要用到的数据结构。&lt;strong&gt;Data Frame&lt;/strong&gt; 在很多的方面都与 &lt;strong&gt;matrix&lt;/strong&gt; 相似，比如 &lt;code&gt;colnames&lt;/code&gt;, &lt;code&gt;dim&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;dataframe&quot;&gt;建立 dataframe&lt;/h3&gt;

&lt;p&gt;建立 &lt;strong&gt;Data Frame&lt;/strong&gt; 的命令是 &lt;code&gt;data.frame&lt;/code&gt;，要求是行数目要相同，列向量允许不同类型的数据。比如，有一个数据是这样的，第一个为姓名，第二个是性别，接着是收入，受教育年限，等等。这些都可以在 &lt;strong&gt;Data Frame&lt;/strong&gt; 共存。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;df &amp;lt;- data.frame(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;))

df

##   x y
## 1 1 a
## 2 2 b
## 3 3 c
## 4 4 d
## 5 5 e


str(df)

## 'data.frame':	5 obs. of  2 variables:
##  $ x: int  1 2 3 4 5
##  $ y: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有一点需要特别注意，&lt;strong&gt;R&lt;/strong&gt; 会默认在数据框里面将字符型（string)转化为因子（factor），如果不想要转化，可以通过参数 &lt;code&gt;stringsAsFactors = FALSE&lt;/code&gt; 来设置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;df_02 &amp;lt;- data.frame(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;), stringsAsFactors = FALSE)

df_02

##   x y
## 1 1 a
## 2 2 b
## 3 3 c
## 4 4 d
## 5 5 e


str(df_02)

## 'data.frame':	5 obs. of  2 variables:
##  $ x: int  1 2 3 4 5
##  $ y: chr  &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;data-frame&quot;&gt;合并 &lt;strong&gt;data frame&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;其实我们在上面介绍向量合并的时候已经接触到这个函数了，即 &lt;code&gt;cbind()&lt;/code&gt; 和 &lt;code&gt;rbind()&lt;/code&gt;。前者是按照列顺序进行合并，后者则是按照行顺序优先进行合并。
- &lt;code&gt;cbind()&lt;/code&gt;：列合并&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   df &amp;lt;- data.frame(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;))
   
   df
   
   ##   x y
   ## 1 1 a
   ## 2 2 b
   ## 3 3 c
   ## 4 4 d
   ## 5 5 e
   
   
   str(df)
   
   ## 'data.frame':	5 obs. of  2 variables:
   ##  $ x: int  1 2 3 4 5
   ##  $ y: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5
   
   
   df_cbind &amp;lt;- cbind(df, data.frame(z = 5:1))
   
   df_cbind
   
   ##   x y z
   ## 1 1 a 5
   ## 2 2 b 4
   ## 3 3 c 3
   ## 4 4 d 2
   ## 5 5 e 1
   
   
   str(df_cbind)
   
   ## 'data.frame':	5 obs. of  3 variables:
   ##  $ x: int  1 2 3 4 5
   ##  $ y: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5
   ##  $ z: int  5 4 3 2 1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;rbind()&lt;/code&gt;：行合并&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;df &amp;lt;- data.frame(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;))
  
df
  
##   x y
## 1 1 a
## 2 2 b
## 3 3 c
## 4 4 d
## 5 5 e
  
  
str(df)
  
## 'data.frame':	5 obs. of  2 variables:
##  $ x: int  1 2 3 4 5
##  $ y: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5
  
  
df_rbind &amp;lt;- rbind(df, data.frame(x = 10, y = &quot;j&quot;))
  
df_rbind
  
##    x y
## 1  1 a
## 2  2 b
## 3  3 c
## 4  4 d
## 5  5 e
## 6 10 j
  
  
str(df_rbind)
  
## 'data.frame':	6 obs. of  2 variables:
##  $ x: num  1 2 3 4 5 10
##  $ y: Factor w/ 6 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5 6
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-9&quot;&gt;提取列向量&lt;/h3&gt;

&lt;p&gt;对于一个 &lt;strong&gt;data frame&lt;/strong&gt;，里面包含了非常多的信息。有时，我们只需要提取其中的某个列向量（也就是一个变量），那么可以使用 &lt;code&gt;$&lt;/code&gt; 来实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;df &amp;lt;- data.frame(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;))

df

##   x y
## 1 1 a
## 2 2 b
## 3 3 c
## 4 4 d
## 5 5 e


df$x

## [1] 1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;

<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></content>
 </entry>
 
 <entry>
   <title>使用 Jekyll + knitr 发布博客</title>
   <link href="http://williamlfang.github.com/cn/2014/01/24/shi-yong--rmarkdown--fa-biao-bo-ke/"/>
   <updated>2014-01-24T00:00:00+08:00</updated>
   <id>http://williamlfang.github.com/cn/2014/01/24/shi-yong--rmarkdown--fa-biao-bo-ke</id>
   <content type="html">&lt;h2 id=&quot;section&quot;&gt;我的博客之旅&lt;/h2&gt;

&lt;p&gt;这些天一直都在钻研如何在博客中加入可以执行 &lt;strong&gt;R&lt;/strong&gt; 程序代码的博客模板。我先前也有过写博客的经历，不过那时候使用的博客都是免费托管在其他的服务器中，一方面是缺乏可定制，大都是千篇一律的，无法满足「DIY」的需要，另一方面，也是主要的问题，这些博客网站很少有支持 &lt;strong&gt;LaTeX&lt;/strong&gt; 的数学输出，对于数学环境的支持不尽人意。我也就偶尔在写一些纯文字类的随想，不曾涉及专业领域的事情。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;后来我实在忍无可忍了，觉得找一个必须是支持 &lt;strong&gt;LaTeX&lt;/strong&gt; 代码的博客网站。这也就只有在 &lt;strong&gt;WordPress&lt;/strong&gt; 上了。我也尝试了使用一段时间。一开始发现还真是方便，直接使用 &lt;strong&gt;LaTeX&lt;/strong&gt; 代码产生数学编译环境，如此一来便可以在上面多说点专业领域的话了。可是，后来我发现在 &lt;strong&gt;WordPress&lt;/strong&gt; 上管理博客与修改模板是一件多么痛苦的事情，既需要更改模板，而且每次改完了发现不是自己想要的效果，又得重新再做。如此一来，光花费在博客网站的维护时间竟然占用了多数。如此不堪重负。&lt;/p&gt;

&lt;p&gt;后来我开始尝试在使用  &lt;strong&gt;R&lt;/strong&gt; 做统计分析，也陆陆续续的写了一些小程序。我的想法是，将 &lt;strong&gt;R&lt;/strong&gt; 强大的数据分析与绘图能力与 &lt;strong&gt;LaTeX&lt;/strong&gt; 超级优美的数学编辑水平结合一起，从而生成既有分析又有数据、既有文本又有图表的文档。后来发现这个想法别人早已实现，那就是 &lt;code&gt;Sweave&lt;/code&gt;，支持在 &lt;strong&gt;LaTeX&lt;/strong&gt; 使用 &lt;strong&gt;R&lt;/strong&gt; 代码 （或者倒过来说，在 &lt;strong&gt;R&lt;/strong&gt; 中使用 &lt;strong&gt;LaTeX&lt;/strong&gt; 语法），并且直接输出结果。再后来，我接着发现这个原来还有『豪华升级版』，那就是我今天要给各位介绍的 &lt;code&gt;knitr&lt;/code&gt;，一个更加强大的支持 &lt;strong&gt;LaTeX&lt;/strong&gt; 编译环境的 &lt;strong&gt;R&lt;/strong&gt; 软件包。&lt;/p&gt;

&lt;p&gt;可是，有时候我不大喜欢 &lt;strong&gt;LaTeX&lt;/strong&gt; 的一点在于，永远都需要那么复杂的插入代码环境，比如，当需要使用「强调」的时候，还得非常复杂而琐碎的键入 &lt;code&gt;\emph{}&lt;/code&gt;，这个让我实在崩溃，因为毕竟我很多时候都是在使用纯文本输入，只是少数地方使用数学公式表达。那么，我想要的就是，需要强调了，就键入 &lt;em&gt;斜体强调&lt;/em&gt;，或者 &lt;strong&gt;粗体强调&lt;/strong&gt;。如此一来，写博客就非常的轻松了。&lt;/p&gt;

&lt;p&gt;于是我在某个凌晨「毅然决然」的将博客编译语言再次转移阵地。这一次，我需要&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;简单：写博客就是写博客，随心所欲，没有多余的格式。在写作过程中，我仅仅需要关心文本，专注于思想表达。&lt;/li&gt;
  &lt;li&gt;支持 &lt;strong&gt;R&lt;/strong&gt; 代码，能够直接产生计算结果，插入图形。而且最好的是，别人看到这个代码还觉得不错，可以自己在电脑上重复输出结果。&lt;/li&gt;
  &lt;li&gt;具有良好的定制特征，我可以根据个人偏好设置网页界面，并且需要很好的可持续维护性。&lt;/li&gt;
  &lt;li&gt;最后是能够记录我在不同时间段写作的备份，方便随时「倒带」。这样我就不用担心删除当下文字段落后以后就找不回来，而且最好是告诉我具体的细节。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;github--jekyll--knitr--rmarkdown&quot;&gt;Github + Jekyll + knitr + Rmarkdown&lt;/h2&gt;

&lt;p&gt;我就抱着这样的「苛刻要求」去找「谷哥」。出乎意料的是，竟然如此简单的就得到需要的解决方案了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Github + Jekyll + Rmarkdown&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这是一个完美的方案！完全实现了我需要的多种服务：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Github&lt;/strong&gt; 用于托管代码与博客。&lt;strong&gt;Git&lt;/strong&gt; 是一款优秀的版本管理软件（VCS），由现在的 &lt;strong&gt;Linux&lt;/strong&gt; 开发团队在维护。而 &lt;strong&gt;Github&lt;/strong&gt; 就相当于一个网罗世界优秀程序员的「Facebook」，汇集了目前几乎所有的开源项目。&lt;/p&gt;

    &lt;p&gt;现在，我可以通过将代码与博客托管到 &lt;strong&gt;Github&lt;/strong&gt; 上，实现版本的系统检测，方便网站运行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll&lt;/strong&gt; 为我的博客网站提供了静态编译，将其打包为 &lt;em&gt;Html&lt;/em&gt; 然后发布在托管的网站上。而且 &lt;strong&gt;Jekyll&lt;/strong&gt; 提供了一系列的模板与模块，方便个人定制网站。与其他博客网站不同，经常动不动的就蹦出一个广告，&lt;strong&gt;Jekyll&lt;/strong&gt; 编制的网站上面不会有多余的信息，我只陈列需要分享的内容。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后，就是 &lt;strong&gt;knitr&lt;/strong&gt; 与 &lt;strong&gt;Rmardown&lt;/strong&gt; 可以轻松的实现博客撰写。现在，我需要做的就是使用 &lt;strong&gt;Markdown&lt;/strong&gt; 语法输入，然后在需要 &lt;strong&gt;R&lt;/strong&gt; 的地方直接插入代码即可。一篇完整的博客就是我沿着自己的想法一路写到底，中间不会有其他的打扰，不要反复的插入格式命令。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rmarkdown&quot;&gt;使用 &lt;strong&gt;Rmarkdown&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;下面，我介绍一下如何实现将 &lt;strong&gt;R&lt;/strong&gt; 代码编译为网页 &lt;strong&gt;Markdown&lt;/strong&gt; 格式。由于 &lt;strong&gt;Jekyll&lt;/strong&gt; 支持将 &lt;strong&gt;Markdown&lt;/strong&gt; 编译成 &lt;strong&gt;Html&lt;/strong&gt; 网页，因此，我们就可以很方便的将 &lt;strong&gt;R&lt;/strong&gt; 文件编译成 &lt;strong&gt;Html&lt;/strong&gt; 并发布到 &lt;strong&gt;Github&lt;/strong&gt; 上面了。我主要参考了 Jason Bryer 的帖子， &lt;a href=&quot;http://jason.bryer.org/posts/2012-12-10/Markdown_Jekyll_R_for_Blogging.html&quot;&gt;“Using (R) Markdown, Jekyll, &amp;amp; GitHub for a Website”&lt;/a&gt;。另外，由于这个帖子生成的图片存储在同样一个文件夹下面，有时我想找某个博客的图片时，会非常的不方便。于是我对其做了一个小小的修改，将经过 &lt;strong&gt;R&lt;/strong&gt; 产生的图片放在与帖子相对应的文件夹目录下，方便查找。比如，我有一个文档，&lt;code&gt;2014-01-24-shi-yong--rmarkdown--fa-biao-bo-ke.Rmd&lt;/code&gt;，那么，图片的存放目录应该是&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-dir&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-assets&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;– images&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;—- r-figures&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;—– 2014-01-24-shi-yong–rmarkdown–fa-biao-bo-ke&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;—— fig1.png&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;rmarkdownr&quot;&gt;建立一个 &lt;code&gt;rmarkdown.r&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;首先是在主目录(&lt;code&gt;_posts&lt;/code&gt;)下面建立一个 &lt;code&gt;rmarkdown.r&lt;/code&gt; 文件，用于执行编译功能。主要用途就是实现将当前目录下所有的带 &lt;code&gt;.Rmd&lt;/code&gt; 文件转化为 &lt;code&gt;.md&lt;/code&gt; 格式，从而可以实现发布。下面是其主要内容，也可以在&lt;a href=&quot;/cn/_post/rmarkdwn.r&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#' This R script will process all R mardown files (those with in_ext file extention,
#' .rmd by default) in the current working directory. Files with a status of
#' 'processed' will be converted to markdown (with out_ext file extention, '.markdown'
#' by default). It will change the published parameter to 'true' and change the
#' status parameter to 'publish'.
#' 
#' @param dir the directory to process R Markdown files.
#' @param images.dir the base directory where images will be generated.
#' @param images.url
#' @param out_ext the file extention to use for processed files.
#' @param in_ext the file extention of input files to process.
#' @param recursive should rmd files in subdirectories be processed.
#' @return nothing.
#' @author Jason Bryer &amp;lt;jason@bryer.org&amp;gt;
convertRMarkdown &amp;lt;- function(dir=getwd(), images.dir=dir, images.url='/cn/assets/images/',
  						 out_ext='.markdown', in_ext='.rmd', recursive=FALSE) {
  	require(knitr, quietly=TRUE, warn.conflicts=FALSE)
  	files &amp;lt;- list.files(path=dir, pattern=in_ext, ignore.case=TRUE, recursive=recursive)
  	for(f in files) {
  		message(paste(&quot;Processing &quot;, f, sep=''))
  		content &amp;lt;- readLines(f)
  	frontMatter &amp;lt;- which(substr(content, 1, 3) == '---')
	  if(length(frontMatter) &amp;gt;= 2 &amp;amp; 1 %in% frontMatter) {
		  statusLine &amp;lt;- which(substr(content, 1, 7) == 'status:')
  		publishedLine &amp;lt;- which(substr(content, 1, 10) == 'published:')
	  	if(statusLine &amp;gt; frontMatter[1] &amp;amp; statusLine &amp;lt; frontMatter[2]) {
		  	status &amp;lt;- unlist(strsplit(content[statusLine], ':'))[2]
  				status &amp;lt;- sub('[[:space:]]+$', '', status)
  			status &amp;lt;- sub('^[[:space:]]+', '', status)
	  		if(tolower(status) == 'process') {
		  		#This is a bit of a hack but if a line has zero length (i.e. a
			  	#black line), it will be removed in the resulting markdown file.
				  #This will ensure that all line returns are retained.
				content[nchar(content) == 0] &amp;lt;- ' '
	  			message(paste('Processing ', f, sep=''))
		  		content[statusLine] &amp;lt;- 'status: publish'
			  	content[publishedLine] &amp;lt;- 'published: true'
				  outFile &amp;lt;- paste(substr(f, 1, (nchar(f)-(nchar(in_ext)))), out_ext, sep='')
  					render_markdown(strict=TRUE)
  				opts_knit$set(out.format='markdown')
	  			opts_knit$set(base.dir=images.dir)
		  		opts_knit$set(base.url=images.url)
  					##
  				## 产生的图片存储位置 `/assets/images/r-figures/`
	  			fig.path &amp;lt;- paste0(&quot;r-figures/&quot;, sub(&quot;.Rmd$&quot;, &quot;&quot;, basename(files)), &quot;/&quot;)
		  		opts_chunk$set(fig.path = fig.path)
			  	## opts_chunk$set(fig.cap = &quot;center&quot;)  ## figure position
			    render_jekyll()     
				  ##
  					try(knit(text=content, output=outFile), silent=FALSE)
  				} else {
  					warning(paste(&quot;Not processing &quot;, f, &quot;, status is '&quot;, status, 
  								&quot;'. Set status to 'process' to convert.&quot;, sep=''))
  				}
  			} else {
  				warning(&quot;Status not found in front matter.&quot;)
  			}
  		} else {
  			warning(&quot;No front matter found. Will not process this file.&quot;)
  		}
  	 }
  	 invisible()
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;rmdsh&quot;&gt;建立可执行文本 &lt;code&gt;rmd.sh&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;这个 &lt;code&gt;rmd.sh&lt;/code&gt; 也是存放在目录 &lt;code&gt;_posts&lt;/code&gt;, 主要就是&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;识别当前的目录，并将其赋予 &lt;code&gt;dir&lt;/code&gt; 参数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;默认在 &lt;code&gt;Terminal&lt;/code&gt; 运行 &lt;code&gt;rmakrdown.r&lt;/code&gt; 的 &lt;code&gt;convertRmarkdown&lt;/code&gt; 函数，并输出经过转化的 &lt;code&gt;.markdown&lt;/code&gt; 文件。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文本 &lt;code&gt;rmd.sh&lt;/code&gt; 可以&lt;a href=&quot;/cn/_post/rmd.sh&quot;&gt;下载&lt;/a&gt;，里面内容是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DIR=&quot;$( cd &quot;$( dirname &quot;${BASH_SOURCE[0]}&quot; )&quot; &amp;amp;&amp;amp; pwd )&quot;
Rscript -e &quot;source('$DIR/rmarkdown.r'); convertRMarkdown(images.dir='../assets/images')&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;yaml-&quot;&gt;添加 &lt;code&gt;YAML&lt;/code&gt; 标头&lt;/h3&gt;

&lt;p&gt;最后，我们需要在 &lt;code&gt;.Rmd&lt;/code&gt; 文件标头添加以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;published: false
status: process
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是因为：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt; - First, the published parameter should be set to false so that Jekyll will not attempt to process the file. The convertRMarkdown function will change this parameter to true in the resulting Markdown file. &lt;/p&gt;
  &lt;p&gt; - The second parameter, status, must be set to process for the convertRMarkdown function to convert the file. This is useful when working a draft of a document and you wish to not have the file converted. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;mathjax&quot;&gt;&lt;strong&gt;MathJax&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;如果想要让 &lt;strong&gt;Jekyll&lt;/strong&gt; 支持数学公式，我们还需要添加插件，&lt;strong&gt;MathJax&lt;/strong&gt;，然后使用 *markdown** 的编译设置为 &lt;strong&gt;kramdown&lt;/strong&gt;。我是这样配置的&lt;/p&gt;

&lt;h4 id=&quot;kramdown&quot;&gt;添加 &lt;strong&gt;kramdown&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;由于我先前使用的是 &lt;em&gt;rdiscount&lt;/em&gt; 来编译 &lt;strong&gt;mardown&lt;/strong&gt; 语法，不能够支持对数学公式的输出。使用的替代是 &lt;strong&gt;kramdown&lt;/strong&gt;，一个更加强大的插件，支持 &lt;em&gt;pdf&lt;/em&gt;， &lt;em&gt;html&lt;/em&gt;，&lt;em&gt;LaTeX&lt;/em&gt; 等格式的转化。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先是在主目录文件夹找到 &lt;code&gt;_config-yml&lt;/code&gt; 打开，将 &lt;strong&gt;markdown&lt;/strong&gt; 默认的编译设置为 &lt;strong&gt;kramdown&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;code&gt;_layout&lt;/code&gt; 目录下面有 &lt;code&gt;post.html&lt;/code&gt; 的页面设置，我们需要在 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 与 &lt;code&gt;&amp;lt;/head&amp;gt;&lt;/code&gt; 之间插入代码
&lt;img src=&quot;/cn/assets/images/r-figures/2014-01-24-shi-yong--rmarkdown--fa-biao-bo-ke/snapshot1.png&quot; alt=&quot;snapshot1.png&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;也就是在网页开启前使用 &lt;strong&gt;MathJax&lt;/strong&gt; 进行编译，支持对数学的输出。这里，我使用单个美元符号 &lt;code&gt;$&lt;/code&gt; 与 &lt;code&gt;$&lt;/code&gt; 输入 &lt;strong&gt;LaTeX&lt;/strong&gt; 代码，会在网页显示相应的 &lt;em&gt;行内公式&lt;/em&gt;，而使用一对的美元符号 &lt;code&gt;$$&lt;/code&gt; 与 &lt;code&gt;$$&lt;/code&gt; 来输入行间数学公式。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;例子&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;数学公式&lt;/h4&gt;

&lt;p&gt;比如我只需要如下输入数学公式，$S = \sum_{i=1}^k x_i$，或者是&lt;script type=&quot;math/tex&quot;&gt;a^2 + b^2 = c^2&lt;/script&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{1}{\pi}=\frac{2\sqrt{2}}{9801}\sum_{k=0}^\infty\frac{(4k)!(1103+26390k)}{(k!)^4396^{4k}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} = 1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}} {1+\frac{e^{-8\pi}} {1+\ldots} } } } &lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

\begin{align}
\mbox{Union: } &amp; A\cup B = \{x\mid x\in A \mbox{ or } x\in B\} \\
\mbox{Concatenation: } &amp; A\circ B  = \{xy\mid x\in A \mbox{ and } y\in B\} \\
\mbox{Star: } &amp; A^\star  = \{x_1x_2\ldots x_k \mid  k\geq 0 \mbox{ and each } x_i\in A\} \\
\end{align}
 %]]&gt;&lt;/script&gt;

&lt;h4 id=&quot;r&quot;&gt;&lt;strong&gt;R&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;再者，这个 &lt;code&gt;R&lt;/code&gt; 代码，我们可以直接生成图片。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = rnorm(100)
plot(density(x))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/cn/assets/images/r-figures/2014-01-24-shi-yong--rmarkdown--fa-biao-bo-ke/fig1.png&quot; alt=&quot;plot of chunk fig1&quot; /&gt; &lt;/p&gt;

<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></content>
 </entry>
 
 <entry>
   <title>Advanced R Programming</title>
   <link href="http://williamlfang.github.com/cn/2014/01/20/r-note/"/>
   <updated>2014-01-20T00:00:00+08:00</updated>
   <id>http://williamlfang.github.com/cn/2014/01/20/r-note</id>
   <content type="html">&lt;p&gt;这个文档记录了我在学习 &lt;a href=&quot;http://had.co.nz/&quot;&gt;Hadley Wickham&lt;/a&gt; 即将出版的新书，&lt;a href=&quot;http://adv-r.had.co.nz/&quot;&gt;Advanced R Programming&lt;/a&gt; 时的一些笔记与总结，以便将来复习查阅。该书博大精深，结构严谨，涵盖面广泛，涉及几乎目前有关「R」的所有问题。从最基础的数据结构开始讲起，然后逐步渐进到如何编写针对问题的 &lt;code&gt;function&lt;/code&gt;，再进阶到如何开发能够发布以供他人使用的 &lt;code&gt;package&lt;/code&gt;。Wickham 本人就是在「R Community」团体中的传奇人物，开发了许多为人称道的宏包，如 &lt;code&gt;ggplot2&lt;/code&gt;等。而本书真是作者在总结了近十年的 「R」软件开发后编写的一本巨著。仔细深入阅读此书必将受益匪浅，极大的提升我们使用与开发「R」的各项技能，真正从最底层去认识「R」这个当今最强大的数据处理、统计分析与图形可视化编程语言。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;正如他自己所说的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I have been programming in R for over 10 years, spending a lot of time trying to figure out how the language works. Not everyone has the luxury of spending years to understand a programming language, so this book is my attempt to help you to become an effective R programmer as quickly as possible. By reading this book, you will avoid the many mistakes that I made and the many dead ends that I got stuck in, and quickly navigate your way to useful tools and techniques. Although R has its frustrating quirks, I truly believe that at its heart lies an elegant and beautiful language, well tailored for data analysis and statistics. In this book, I’ll do my best to reveal that language to you, helping you to understand powerful idioms that allow you to attack many types of problems.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;why-r&quot;&gt;Why 「R」&lt;/h2&gt;

&lt;p&gt;对于这个问题的回答，最简短的回答是&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;多学一门编程语言总不会死吧？！！！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;确实，在当今这个互联网与信息时代，我们的生活与工作与电脑紧密相连、形影不离，如果要想了解这个时代、这个世界，我们首先必须先了解那些控制与主宰了我们生活节奏的「电脑们」是如何「生活」的。进一步说，即那些操控了「电脑们」的&lt;strong&gt;「程序」&lt;/strong&gt;是如何运行的。而所谓的「程序」，终归到底，是「程序语言」（Programming language）。前几年流行的一本「Hakers and Painters」就在序言开宗明义地说：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Everything around us is turning into computers. Your typewriter is gone, replaced by a computer. Your phone has turned into a computer. So has your camera. Soon your Tv will. Your car was not only designed on computers, but has more processing power in it than a room-sized mainframe did in 1970. Letters, encyclopedias, newspapers, and even your local store are being replaced by the Internet.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因此，我们要想了解世界，就必须先懂得这个世界在说什么（编程）「语言」。所谓「技多不压身」，多学习一门「编程语言」也促使我们从另外一个角度看世界，多一种批判的眼光，多一层思维的觉悟。何乐而不为？&lt;/p&gt;

&lt;p&gt;当然，如果你是首次听说/接触「R」，对这个编程语言一点冲动的想法都没有，那我就需要找各种&lt;em&gt;理由&lt;/em&gt;来劝说你「是时候该学习『R』了」，哪怕是对阅读统计报告的需要。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注意&lt;/em&gt;：真是下面的几条&lt;em&gt;Reasons&lt;/em&gt;把我拉入了「R」介个广大的「神教」中，有幸或不幸，我也希望你来加入！&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;「R」是处理统计数据与图形可视化的「神器」，能够高效的完成各种数据分析，生成信息充实而页面精美的图形。一方面，我们可是直接使用现今已有的软件包（通过&lt;code&gt;install.packages(&quot;&quot;)&lt;/code&gt;)，涵盖了从基本的统计分析方法，如计算均值，方差分析，到时下最前沿的统计方法，可用于处理有关统计建模、机器学习、大数据管理等问题;另一方面，如果发现现有的软件包不能满足或者不适合手头问题的解决，那么我们还可以自己动手开发。这个特性赋予了「R」强大的处理数据的能力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;「R」是一款&lt;strong&gt;自由的开源软件体&lt;/strong&gt;。这意味着你有权限去获取、使用、修改甚至是发行任何版本的「R」程序。这一点对于使用&lt;code&gt;Windows&lt;/code&gt;的用户可能不会意识到有多重要，因为在国内的环境中，我们从来都没有关心过一款软件的「版权」问题，心想着反正上网有大量的破解软件可供下载使用。可是对于一个合格的哪怕只是刚入门的「Geek」来说，我已经不能再忍受破解（=盗版=病毒）软件的荼毒。从网上某处下载的软件，总是神乎其神的在某个地方给你添加插件，修改管理者权限，安装不必要也不想要的软件。然后在某天开机之后，屏幕变黑，系统变坏，情绪变糟。&lt;/p&gt;

    &lt;p&gt;后来我开始转移阵地到「Linux」，开始慢慢接触开源项目，才逐渐领会到开源软件带来的自由。比如，我可以从互联网以「正当理由」、「合理方式」获得所需的软件，并能够在尊重原开发者的情况下修改软件，生成「私人定制」，我甚至还可以将其发布到网上供他人使用。涉及到软件的自由是多层次的，其中最基本的一条就是，我可以修改、进一步开发以利解决问题。&lt;/p&gt;

    &lt;p&gt;「R」就是这么一个软件，她给你所需，为你所用，助你之力。&lt;/p&gt;

    &lt;p&gt;同时，「R」的开源特性也意味着这是一个免费的软件，我们可以以零成本的价格使用。这对于一枚「学生党」，有着「千情万钟」的诱惑（刨去破解软件）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分散在世界各地的「R Community」为这个编程语言持续地注入新鲜的生命力，使之长久延续。我们可以到「CRAN」、&lt;a href=&quot;https://stat.ethz.ch/mailman/listinfo/r-help&quot;&gt;R-help mailing list&lt;/a&gt;、&lt;a href=&quot;http://stackoverflow.com/questions/tagged/r&quot;&gt;StackOverflow&lt;/a&gt;寻求帮助，也可以通过当地的「R user group」来咨询方案。不同与其他的编程语言，「R」的开源共享的属性让她得到世界各地用户的偏好，共同开发以保持其活力。我们无需担心哪一天自己辛苦学习与使用的编程语言/软件就撒手不干停止更新服务了。因此，学习「R」几乎是一个「零（违约）风险」的投资。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可重复（reproducable）研究指得是在现有的数据框架下，我们可以通过复制原来研究成果的代码来验证其准确性。这区别于更加广泛意义上的可复制（replecated）研究，即需要重新收集数据样本来复制结果。可重复研究允许我们在有限的经费预算约束下，极大可能的验证科学研究成果。&lt;/p&gt;

    &lt;p&gt;「R」正是开发可重复研究的利器，提供了像&lt;code&gt;knitr&lt;/code&gt;这样优秀的软件包，使得统计分析的任何一个过程都可以通过运行代码来检验研究成果。同时，我们还可以在文章正文中「植入」程序代码，直接计算结果（面向对象，object-oriented）、绘制图形（ggplot2）、编制表格（tabular，xtable）。这省去了传统的撰写文章的麻烦与琐碎。比如，原先我们可能是在「LaTex」中写入论述，等到了需要使用图形的地方，需要事先标明&lt;code&gt;\includegraphic{}&lt;/code&gt;，然后通过查找对应的图片插入。这期间被各种「烦文缛节」、各种「黑暗技巧」搞得晕头转向、不知何处。最后搞不好还弄错了文字与图形的匹配。而这些统统在&lt;code&gt;knitr&lt;/code&gt;中可以自动完成，我们需要的，就是顺着思维的路线一路走下去，该说人话的时候就写人话，该使用机器语言就直接健入代码产生需要的结果或者图形。真可谓&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;「R」与「LaTex」齐飞，思想代码共一体。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;此外，「R」还是一个&lt;em&gt;跨平台&lt;/em&gt;的软件体，通吃「三界」：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Windows系统可以直接点击&lt;code&gt;.exe&lt;/code&gt;软件来安装;&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Linux系统使用命令安装：&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; sudo apt-get install r-base r-base-dev
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;Mac系统。（抱歉，我没有使用Mac，故此处不敢高声语。）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;why-not-r&quot;&gt;Why &lt;em&gt;Not&lt;/em&gt; 「R」&lt;/h2&gt;

&lt;p&gt;对于这个问题，我真的不知该如何回答。如果说以上的几点理由还不够具有「杀伤力」，那在下也只能自愧功力不够、道行尚浅、修行有限。&lt;/p&gt;

&lt;p&gt;不过还好，大神来帮忙了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Of course, R is not perfect. R’s biggest challenge is that most R users are not programmers.     &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;他给出的批评无非是「double-edged sword」，所谓凡是有利有弊、一正一邪。各位看官可以到大神的网上去找找不使用「R」的「牵强附会」的理由。在下无需多言，只不过再此累赘一下，也算是个人当初的体会。&lt;/p&gt;

&lt;p&gt;「R」的学习曲线太陡峭、成本太高了。也就是说，对于一个初学者来说，「R」的代码几乎可以说是「摧枯拉朽」、「灭顶之灾」的。原因有二：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;R&lt;/strong&gt; 掺杂了其他语言的使用，如&lt;strong&gt;C&lt;/strong&gt;，&lt;strong&gt;Python&lt;/strong&gt;。这旨在提高「R」的运行速度与计算能力，增强数据分析。不过这对「beginner」却造成了困扰。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;我的建议是：既来之，则安之。一开始看不懂没关系，先试着挑-「好看」的来，然后再进一步深入学习。等到你真正需要扩展的时候，再去找些资料学习就可以了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;R&lt;/strong&gt; 对于编写程序没有过于严格的要求，是真正意义上的「注重结果」的编程语言。这直接造成了「恶劣影响」，导致许多的代码行都不大注重严谨，缺乏统一。看不懂别人的代码那是必须的，有时甚至都看不懂自己以前写的代码了。,,Ծ‸Ծ,,&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;推荐：多看多看多看！没见过猪跑也好歹有吃过猪肉。另外，可以看看一些「guide」，养成良好的编写程序的习惯，比如，大神的&lt;a href=&quot;http://adv-r.had.co.nz/Style.html&quot;&gt;建议&lt;/a&gt;,以及&lt;a href=&quot;http://google-styleguide.googlecode.com/svn/trunk/Rguide.xml&quot;&gt;Google’s R Style Guide&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></content>
 </entry>
 
 <entry>
   <title>WineQQ2013 可以使用</title>
   <link href="http://williamlfang.github.com/cn/2014/01/18/qq-for-linux/"/>
   <updated>2014-01-18T00:00:00+08:00</updated>
   <id>http://williamlfang.github.com/cn/2014/01/18/qq-for-linux</id>
   <content type="html">&lt;h2 id=&quot;qq-for-linux&quot;&gt;QQ for &lt;code&gt;Linux&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;想要在Linux操作系统下使用 &lt;code&gt;QQ&lt;/code&gt; 真的得费不少劲。我之前尝试通过 &lt;code&gt;WINE&lt;/code&gt; 来安装 &lt;code&gt;QQ2013&lt;/code&gt;，可是最终以失败结束。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一方面是由于目前的 &lt;code&gt;WINE&lt;/code&gt; 技术还不是很好，对于一些商业软件支持力度不够，也不能完全模拟 &lt;code&gt;Windows&lt;/code&gt; 系统来安装 &lt;code&gt;.exe&lt;/code&gt; 的软件（如果完全取代了，怎么感觉又回到 &lt;code&gt;Windows&lt;/code&gt; 时代了呢…..），期间需要不停的下载相关而不必要的软件，大费人力与（电）脑力，而且终归落得个不能使用/中文乱码的惨淡结局。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另一方面，&lt;code&gt;Tencent&lt;/code&gt; 公司也不会完全放弃 &lt;code&gt;QQ&lt;/code&gt; 的商业价值来满足开源爱好者的，他们满眼看到的是商业利益。&lt;code&gt;QQ&lt;/code&gt; 本身是一个具有黑暗魔法力量的软件，可以推送广告取得收入，可以不间断的搜索用户资料（先前有 3Q 大战及由此来），还能维护一个庞大的软件生态链。故此，虽然曾经有一段时间的 &lt;code&gt;QQ for Linux&lt;/code&gt; 的美好光景，却也一去不复返。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们现在想要在 Linux 上使用 &lt;code&gt;QQ&lt;/code&gt;，真可谓“斗智斗勇”，方能取得一丁点的成就。&lt;/p&gt;

&lt;h2 id=&quot;qq&quot;&gt;虚拟机下使用 QQ&lt;/h2&gt;
&lt;p&gt;我之前有在一篇关于虚拟机 &lt;a href=&quot;http://williamlfang.github.io/cn/2014/01/04/virtualbox/&quot;&gt;virtualbox&lt;/a&gt; 的文章中谈过可以利用虚拟机来运行 &lt;code&gt;Windows&lt;/code&gt; 操作系统，并在其使用 &lt;code&gt;QQ&lt;/code&gt; 等软件。可以，这也很不方便，为了使用一个软件大开虚拟机占用大量的内存，实属不值，何况对于一些老机子更是苦命。因此，我决定放弃这个既浪费资源又不讨好的想法，另辟蹊径。&lt;/p&gt;

&lt;h2 id=&quot;wineqq&quot;&gt;WineQQ&lt;/h2&gt;
&lt;p&gt;目前，由一个叫做 “LongeneTeam” 团队给广大的用户带来了福音。他们号称开发了史上最牛叉的、能够在 Linux 系统运行的 &lt;code&gt;wineQQ&lt;/code&gt;。其工作原理是：
&amp;gt; 通过以deb的格式将 QQ 软件、Wine基本配置、有关字体以及一些必要的配件统统打包好，这样用户可以直接点击deb文件来安装、使用 QQ。&lt;/p&gt;

&lt;p&gt;目前 wineQQ 的最新版本为 &lt;a href=&quot;http://www.longene.org/forum/viewtopic.php?t=4700&quot;&gt;wine-1.7.9&lt;/a&gt;。deb格式的软件可以在&lt;a href=&quot;http://pan.baidu.com/s/1hq83fWo&quot;&gt;这里&lt;/a&gt;或者&lt;a href=&quot;http://www.longene.org/download/WineQQ2013SP6-20140102-Longene.deb&quot;&gt;这里&lt;/a&gt;下载到。之后可以直接双击打开，经由 &lt;code&gt;Software Manager&lt;/code&gt; 确认系统密码后即可安装。完成之后在找到 &lt;code&gt;QQ&lt;/code&gt; 打开即可。
&lt;img src=&quot;/cn/assets/images/QQ/qq.png&quot; alt=&quot;wineqq2013&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;问题之门及解决之道&lt;/h2&gt;
&lt;p&gt;以下汇集了我在使用 wineQQ2013 过程中遇到的一些问题，以及相应的解决方法。欢迎补充。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;64位操作系统不能运行&lt;/h3&gt;
&lt;p&gt;这个问题主要是由于原先只是在32位系统运行的 &lt;code&gt;wineQQ&lt;/code&gt; 需要安装配件。如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;&lt;span class=&quot;lineno&quot;&gt;1&lt;/span&gt; sudo apt-get install libc6-i386 
&lt;span class=&quot;lineno&quot;&gt;2&lt;/span&gt; sudo apt-get install ia32-libs
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></content>
 </entry>
 
 <entry>
   <title>Images</title>
   <link href="http://williamlfang.github.com/cn/2014/01/18/img/"/>
   <updated>2014-01-18T00:00:00+08:00</updated>
   <id>http://williamlfang.github.com/cn/2014/01/18/img</id>
   <content type="html">&lt;p&gt;This thread will show you how to add a new images in Markdown through &lt;code&gt;relative path&lt;/code&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Make sure that you have already set the &lt;code&gt;url&lt;/code&gt; correctly as &lt;code&gt;williamlfang.github.com&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now that we wanna to add new images in the website as &lt;code&gt;williamlfang.github.com/cn&lt;/code&gt;, which is a &lt;code&gt;gh-pages&lt;/code&gt;. Unfortunely, all the &lt;code&gt;url&lt;/code&gt; links are directed to the main repo &lt;code&gt;williamlfang.github.com&lt;/code&gt; instead of the &lt;code&gt;williamlfang.github.com/cn&lt;/code&gt;. This is what the following to be utilized.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Suppose you have created a relative path containing folder as &lt;code&gt;assets/images/btt.png&lt;/code&gt;, all you need to do is to add the additional prelix &lt;code&gt;/cn&lt;/code&gt; alongsie the relative file path &lt;code&gt;assets/images/btt.png&lt;/code&gt;. See below as as example: &lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;!&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;bottom&lt;span class=&quot;o&quot;&gt;](&lt;/span&gt;/cn/assets/images/btt.png&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;which gives
&lt;img src=&quot;/cn/assets/images/btt.png&quot; alt=&quot;bottom&quot; /&gt;&lt;/p&gt;
<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></content>
 </entry>
 
 <entry>
   <title>Linux Mint 安装 Pandoc</title>
   <link href="http://williamlfang.github.com/cn/2014/01/16/pandoc/"/>
   <updated>2014-01-16T00:00:00+08:00</updated>
   <id>http://williamlfang.github.com/cn/2014/01/16/pandoc</id>
   <content type="html">&lt;h2 id=&quot;linux-mint--pandoc&quot;&gt;下面介绍在 Linux Mint 系统下如何安装 pandoc。&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如官网介绍，安装 pandoc
 sudo apt-get install cabal-install
 cabal update
 cabal install pandoc&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加路径，
 sudo gedit /etc/profile
  在打开的文档最后输入
 export PATH=/home/william/.cabal/bin:$PATH
  再到 
 cd /etc/
 source profile&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;再次重新
 cabal install pandoc pandoc-citeproc&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看是否安装成功
 pandoc –version&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></content>
 </entry>
 
 <entry>
   <title>Linux 中文输入法（fcitx）安装与设置</title>
   <link href="http://williamlfang.github.com/cn/2014/01/08/chinese-input/"/>
   <updated>2014-01-08T00:00:00+08:00</updated>
   <id>http://williamlfang.github.com/cn/2014/01/08/chinese-input</id>
   <content type="html">&lt;p&gt;Linux （Mint，16 Petra）系统本身并没有默认安装中文输入法。为了在 Linux 操作系统下使用中文输入，需要自己添加。我倒腾了大半天的，终于明白过来这是怎么设置了。现在将全部的过程记录在下面，以备日后使用。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先是安装源，&lt;/p&gt;

    &lt;p&gt;sudo add-apt-repository ppa:fcitx-team/nightly&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;更新&lt;/p&gt;

    &lt;p&gt;sudo apt-get update&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装 fcitx，搜狗输入法，五笔（一般不用），以及双拼&lt;/p&gt;

    &lt;p&gt;sudo apt-get install fcitx fcitx-sogoupinyin fcitx-table-wubi fcitx-pinyin&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这个比较重要，可以先在终端输入 fcitx，看看是不是提示没有可用的前端，则需要安装如下 &lt;code&gt;fcitx-frontend-gtk3&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;sudo apt-get install fcitx-frontend-gtk3 fcitx-ui-classic&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;打开 fcitx config，如果提示 “fcitx 的 KCModule 未被找到 缺少”，则在Terminator输入&lt;/p&gt;

    &lt;p&gt;sudo apt-get install kde-config-fcitx&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 &lt;code&gt;fconfig&lt;/code&gt; 设置输入法即可使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要在 &lt;code&gt;/home&lt;/code&gt; 文件夹下面新建/修改 &lt;code&gt;.xprofile&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;export LC_ALL=zh_CN.utf8        &lt;br /&gt;
export XMODIFIERS=@im=fcitx        &lt;br /&gt; 
export QT_IM_MODULE=xim        &lt;br /&gt;
export GTK_IM_MODULE=xim        &lt;br /&gt; 
fcitx -d        &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></content>
 </entry>
 
 
</feed>
