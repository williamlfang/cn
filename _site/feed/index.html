<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>William Fang</title>
    <atom:link href="http://williamlfang.github.com/cn/feed/" rel="self" type="application/rss+xml" />
    <link>http://williamlfang.github.com</link>
    <lastBuildDate>2014-01-26T23:04:55+08:00</lastBuildDate>
    <webMaster>william.lian.fang@gmail.com</webMaster>
    
    <item>
      <title>Data Structure</title>
      <link>http://williamlfang.github.com/cn/2014/01/26/data-structure/</link>
      <pubDate>2014-01-26T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/26/data-structure</guid>
      <content:encoded><![CDATA[<p>这一章主要介绍了在 <strong>R</strong> 中最基本的元素：数据。前段时间我在网上看到一个帖子（暂时忘记在哪里找到了），强调「data science」的重心不是在前面的那个「data」，而是后面的「science」。这是因为随着互联网的深入发展，我们现在不再是缺乏数据，反而是面临着「big data」造成的「information rich」（信息冗余）的困扰。因此，今后的数据科学应当更进一步的发展新的理论与方法来解决大数据分析。</p>

<p>好了，这个扯远了。不过在 <strong>R</strong> 中，我们最紧要的事情就是：给了一大箩筐的数据，可能是排列完整的，不过大多数情况下是混乱不堪的，要求对这些数据做统计分析与可视化工作。这个基本上是一件既头疼又心烦的苦差事。首先的任务是，先对这些数据做一定格局的处理，得到我们后续需要使用的信息变量。因此，熟练掌握处理数据的基本方法，对未来的分析至关重要。</p>

<h2 id="section">概览</h2>

<p>Wickham 用一张表格总结了 <strong>R</strong> 中的数据结构</p>

<blockquote>
  <p>R’s base data structures are summarised in the table below, organised by their dimensionality and whether they’re homogeneous (all contents must be of the same type) or heterogeneous (the contents can be of different types):</p>

  <table>
    <thead>
      <tr>
        <th> </th>
        <th>Homogeneous</th>
        <th>Heterogeneous</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>1d</td>
        <td>Atomic vector</td>
        <td>List</td>
      </tr>
      <tr>
        <td>2d</td>
        <td>Matrix</td>
        <td>Data frame</td>
      </tr>
      <tr>
        <td>nd</td>
        <td>Array</td>
        <td> </td>
      </tr>
    </tbody>
  </table>
</blockquote>

<p>需要解释的是标量（scalar）。什么是标量呢？就是一个个单独的变量，如</p>

<div class="highlight"><pre><code class="r">x <span class="o">&lt;-</span> <span class="m">5</span>
y <span class="o">&lt;-</span> <span class="s">&quot;scalar&quot;</span>

x
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [1] 5
</code></pre>
</div>

<div class="highlight"><pre><code class="r">y
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [1] &quot;scalar&quot;
</code></pre>
</div>

<p><strong>R</strong> 默认地将标量识别为 1*1 的向量（vector），也就是 0-dimensional。</p>

<blockquote>
  <p>这里科普一下有关 <strong>R</strong> 中的面向对象的特征。也就是说， <strong>R</strong> 中所有的元素都可以叫做「对象」（obgect），这不仅仅是基本的数据，如向量、data frame，还包括函数（function）、环境（environment），甚至是符号（symbols）。 <strong>R</strong> 处理完分析后得到的就是一个对象，我们需要哪儿元素，直接提取就可以了。比如，</p>

</blockquote>

<div class="highlight"><pre><code class="r">    df <span class="o">=</span> data.frame<span class="p">(</span>x <span class="o">=</span> rnorm<span class="p">(</span><span class="m">100</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span> y <span class="o">=</span> seq<span class="p">(</span>from <span class="o">=</span> <span class="m">1</span><span class="p">,</span> to <span class="o">=</span> <span class="m">100</span><span class="p">))</span>
    result <span class="o">&lt;-</span> lm<span class="p">(</span>y <span class="o">~</span> x<span class="p">,</span> data <span class="o">=</span> df<span class="p">)</span>
    
    result
    
</code></pre>
</div>

<div class="highlight"><pre><code class="text">    ## 
    ## Call:
    ## lm(formula = y ~ x, data = df)
    ## 
    ## Coefficients:
    ## (Intercept)            x  
    ##      50.487        0.889
    
</code></pre>
</div>

<blockquote>
  <p>得到的结果存储在 <code>result</code> 里，这个就是一个对象，等到我们需要使用其中的「子对象」时，再从中提取即可</p>
</blockquote>

<div class="highlight"><pre><code class="r">    result<span class="o">$</span>coeff
    
</code></pre>
</div>

<div class="highlight"><pre><code class="text">    ## (Intercept)           x 
    ##     50.4870      0.8888
    
</code></pre>
</div>

<p>面向对象的编程能够提供非常灵活的数据处理结果，并且具有较高的程序维护性。这在 <strong>R</strong> 得到了极大的展现。</p>

<h3 id="str"><code>str()</code>：查看数据结构</h3>
<p>查看数据类型可以使用命令 <code>str()</code> </p>

<div class="highlight"><pre><code class="r">str<span class="p">(</span>df<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## &#39;data.frame&#39;:	100 obs. of  2 variables:
##  $ x: num  0.833 -1.63 2.132 -0.588 -0.3 ...
##  $ y: int  1 2 3 4 5 6 7 8 9 10 ...
</code></pre>
</div>

<h2 id="section-1">向量</h2>

<p>如上所述， <strong>R</strong> 中主要的一维数据类型包括 <code>atomic vector</code>（基础向量） 和 <code>list</code>（列表），前者要求罗列其中的数据均是同属性的，比如 <code>logical</code>，<code>interger</code>，<code>double</code>，和 <code>character</code>。而后者 <code>list</code> 则可以是多种数据类型的混合。</p>

<h3 id="section-2">基础向量</h3>

<p>基础向量是组成 <strong>R</strong> 编程语言的基石，可以由此构成其他类型的数据结构。怎么去理解  <strong>R</strong> 中的向量呢？</p>

<h4 id="section-3">数据的向量化</h4>

<p>其实，这个可以看作是一个研究变量的序列观测值。比如</p>

<div class="highlight"><pre><code class="r">x <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">35.6</span><span class="p">,</span> <span class="m">36.1</span><span class="p">,</span> <span class="m">35.8</span><span class="p">,</span> <span class="m">37</span><span class="p">,</span> <span class="m">36.5</span><span class="p">,</span> <span class="m">37.2</span><span class="p">,</span> <span class="m">35.8</span><span class="p">)</span>
str<span class="p">(</span>x<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">##  num [1:7] 35.6 36.1 35.8 37 36.5 37.2 35.8
</code></pre>
</div>

<div class="highlight"><pre><code class="r">is.vector<span class="p">(</span>x<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [1] TRUE
</code></pre>
</div>

<p>这个就是一个向量，可以视为一天中在七个不同时间段的气温观测。因此，我们可以利用这个向量来产生矩阵，从而实现多元变量在不同时间序列上的观测值。其实，这种数据的向量化不仅提供了对数据的直观理解，而且还能提高 <strong>R</strong> 的运算速度，尽量避免使用循环，优化程序。这点我们在日后会继续讨论。</p>

<h4 id="section-4">生成向量的方法</h4>

<p>用于生成向量的命令主要有：</p>

<ul>
  <li><code>c()</code>:即「concantinate」的意思，用于生成一个向量，并且可用于嵌套</li>
</ul>

<div class="highlight"><pre><code class="r">    a <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">8</span><span class="p">)</span>
    b <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">1</span><span class="p">,</span> c<span class="p">(</span><span class="m">2</span><span class="p">,</span> c<span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="m">6.8</span><span class="p">)))</span>  <span class="c1"># 套嵌使用</span>
    a <span class="o">==</span> b
    
</code></pre>
</div>

<div class="highlight"><pre><code class="text">    ## Warning: longer object length is not a multiple of shorter object length
    
</code></pre>
</div>

<div class="highlight"><pre><code class="text">    ## [1]  TRUE  TRUE  TRUE FALSE FALSE
    
</code></pre>
</div>

<div class="highlight"><pre><code class="r">    
    s <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">10</span><span class="p">)</span>  <span class="c1"># 一个序列。相当于 seq(from = 1, to = 10, by= 1)</span>
    s
    
</code></pre>
</div>

<div class="highlight"><pre><code class="text">    ##  [1]  1  2  3  4  5  6  7  8  9 10
    
</code></pre>
</div>

<div class="highlight"><pre><code class="r">    
    int <span class="o">&lt;-</span> c<span class="p">(</span><span class="m">1L</span><span class="p">,</span> <span class="m">6L</span><span class="p">,</span> <span class="m">8L</span><span class="p">)</span>  <span class="c1"># 产生integer类</span>
    
    log <span class="o">&lt;-</span> c<span class="p">(</span><span class="k-Variable">T</span><span class="p">,</span> <span class="k-Variable">F</span><span class="p">,</span> <span class="k-Variable">F</span><span class="p">,</span> <span class="k-Variable">T</span><span class="p">,</span> <span class="k-Variable">T</span><span class="p">)</span>  <span class="c1"># logical</span>
    
    chr <span class="o">&lt;-</span> c<span class="p">(</span><span class="s">&quot;these&quot;</span><span class="p">,</span> <span class="s">&quot;are&quot;</span><span class="p">,</span> <span class="s">&quot;some&quot;</span><span class="p">,</span> <span class="s">&quot;character&quot;</span><span class="p">)</span>
    
</code></pre>
</div>

<ul>
  <li><code>seq()</code>:即「sequence」的意思，主要用于产生一个带有规律的序列        </li>
</ul>

<div class="highlight"><pre><code class="r">    f <span class="o">&lt;-</span> seq<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">10</span><span class="p">)</span>  <span class="c1"># 默认的increament是1,相当于 c(1:10)</span>
    f
    
</code></pre>
</div>

<div class="highlight"><pre><code class="text">    ##  [1]  1  2  3  4  5  6  7  8  9 10
    
</code></pre>
</div>

<div class="highlight"><pre><code class="r">    
    g <span class="o">&lt;-</span> seq<span class="p">(</span>from <span class="o">=</span> <span class="m">1</span><span class="p">,</span> to <span class="o">=</span> <span class="m">10</span><span class="p">,</span> by <span class="o">=</span> <span class="m">0.5</span><span class="p">)</span>
    
    g
    
</code></pre>
</div>

<div class="highlight"><pre><code class="text">    ##  [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5
    ## [15]  8.0  8.5  9.0  9.5 10.0
    
</code></pre>
</div>

<ul>
  <li><code>rep()</code>:即[replecate],重复某个数或者某个「序列」，可用于产生较为复杂的数据。</li>
</ul>

<div class="highlight"><pre><code class="r">    h <span class="o">&lt;-</span> rep<span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="m">10</span><span class="p">)</span>  <span class="c1"># 单个数字的重复</span>
    h
    
</code></pre>
</div>

<div class="highlight"><pre><code class="text">    ##  [1] 5 5 5 5 5 5 5 5 5 5
    
</code></pre>
</div>

<div class="highlight"><pre><code class="r">    
    j <span class="o">&lt;-</span> rep<span class="p">(</span>c<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">),</span> <span class="m">3</span><span class="p">)</span>  <span class="c1"># 重复一个序列 c(1:3)</span>
    j
    
</code></pre>
</div>

<div class="highlight"><pre><code class="text">    ## [1] 1 2 3 1 2 3 1 2 3
    
</code></pre>
</div>

<ul>
  <li><code>rnorm()</code>:产生随机数，还有其他的分布</li>
</ul>

<div class="highlight"><pre><code class="r">    k <span class="o">&lt;-</span> rnorm<span class="p">(</span><span class="m">100</span><span class="p">)</span>  <span class="c1">#default：rnorm(no, mean = 0, sd = 1)</span>
    
    l <span class="o">&lt;-</span> rnorm<span class="p">(</span><span class="m">100</span><span class="p">,</span> mean <span class="o">=</span> <span class="m">2</span><span class="p">,</span> sd <span class="o">=</span> <span class="m">5</span><span class="p">)</span>
    plot<span class="p">(</span>density<span class="p">(</span>l<span class="p">))</span>
    
</code></pre>
</div>

<pre><code>![plot of chunk unnamed-chunk-9](/cn/assets/images/r-figures/2014-01-24-shi-yong--rmarkdown--fa-biao-bo-ke/unnamed-chunk-9.r-figures/2014-01-26-data-structure/unnamed-chunk-9.png) 
</code></pre>

<h4 id="section-5">类型与长度</h4>

<p><code>typeof()</code> 用于查看数据类型，而 <code>length()</code> 则用于查看向量长度：如果是一维数据，则给出长度；如果是矩阵或者 <code>data.frame</code>，则给出 <code>nrow</code> 与 <code>ncol</code> 的合计。</p>

<div class="highlight"><pre><code class="r">x <span class="o">&lt;-</span> rnorm<span class="p">(</span><span class="m">100</span><span class="p">)</span>
typeof<span class="p">(</span>x<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [1] &quot;double&quot;
</code></pre>
</div>

<div class="highlight"><pre><code class="r">length<span class="p">(</span>x<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [1] 100
</code></pre>
</div>

<div class="highlight"><pre><code class="r">y <span class="o">&lt;-</span> c<span class="p">(</span><span class="s">&quot;first&quot;</span><span class="p">,</span> <span class="s">&quot;second&quot;</span><span class="p">,</span> <span class="s">&quot;third&quot;</span><span class="p">)</span>
typeof<span class="p">(</span>y<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [1] &quot;character&quot;
</code></pre>
</div>

<div class="highlight"><pre><code class="r">length<span class="p">(</span>y<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [1] 3
</code></pre>
</div>

<div class="highlight"><pre><code class="r">z <span class="o">&lt;-</span> c<span class="p">(</span><span class="k-Variable">T</span><span class="p">,</span> <span class="k-Variable">T</span><span class="p">,</span> <span class="k-Variable">F</span><span class="p">)</span>
typeof<span class="p">(</span>z<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [1] &quot;logical&quot;
</code></pre>
</div>

<div class="highlight"><pre><code class="r">length<span class="p">(</span>z<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [1] 3
</code></pre>
</div>

<div class="highlight"><pre><code class="r">w <span class="o">&lt;-</span> seq<span class="p">(</span>from <span class="o">=</span> <span class="m">1</span><span class="p">,</span> to <span class="o">=</span> <span class="m">10</span><span class="p">,</span> by <span class="o">=</span> <span class="m">1</span><span class="p">)</span>
typeof<span class="p">(</span>w<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [1] &quot;double&quot;
</code></pre>
</div>

<div class="highlight"><pre><code class="r">length<span class="p">(</span>w<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [1] 10
</code></pre>
</div>

<div class="highlight"><pre><code class="r">mat <span class="o">&lt;-</span> matrix<span class="p">(</span>rnorm<span class="p">(</span><span class="m">20</span><span class="p">),</span> nrow <span class="o">=</span> <span class="m">4</span><span class="p">,</span> ncol <span class="o">=</span> <span class="m">5</span><span class="p">)</span>
typeof<span class="p">(</span>mat<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [1] &quot;double&quot;
</code></pre>
</div>

<div class="highlight"><pre><code class="r">length<span class="p">(</span>mat<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [1] 20
</code></pre>
</div>

<h3 id="list"><code>list</code>:列表</h3>

<p>我们已经知道，<code>vector</code>是用于同种类型属性的数据，而<code>list</code>则适用于不同类型的数据，可以说是各种数据的一个「大火锅」。我们使用<code>list()</code>来生成数据，不是之前介绍的<code>c()</code>。</p>

<div class="highlight"><pre><code class="r">u <span class="o">&lt;-</span> list<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">,</span> <span class="s">&quot;cha&quot;</span><span class="p">,</span> <span class="k-Variable">T</span><span class="p">,</span> <span class="k-Variable">F</span><span class="p">,</span> c<span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">7</span><span class="p">),</span> rep<span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">3</span><span class="p">),</span> seq<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">5</span><span class="p">))</span>

u
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [[1]]
## [1] 1 2 3
## 
## [[2]]
## [1] &quot;cha&quot;
## 
## [[3]]
## [1] TRUE
## 
## [[4]]
## [1] FALSE
## 
## [[5]]
## [1] 1 4 7
## 
## [[6]]
## [1] 1 1 1
## 
## [[7]]
## [1] 1 2 3 4 5
</code></pre>
</div>

<div class="highlight"><pre><code class="r">str<span class="p">(</span>u<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## List of 7
##  $ : int [1:3] 1 2 3
##  $ : chr &quot;cha&quot;
##  $ : logi TRUE
##  $ : logi FALSE
##  $ : num [1:3] 1 4 7
##  $ : num [1:3] 1 1 1
##  $ : int [1:5] 1 2 3 4 5
</code></pre>
</div>

<div class="highlight"><pre><code class="r">typeof<span class="p">(</span>u<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [1] &quot;list&quot;
</code></pre>
</div>

<p>当然，<code>list</code>也可以跟<code>c()</code>一样实现套嵌 (Wickham称之为[recursive])</p>

<div class="highlight"><pre><code class="r">v <span class="o">&lt;-</span> list<span class="p">(</span>list<span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="k-Variable">T</span><span class="p">,</span> <span class="s">&quot;nope&quot;</span><span class="p">,</span> seq<span class="p">(</span><span class="m">4</span><span class="o">:</span><span class="m">8</span><span class="p">)),</span> rep<span class="p">(</span><span class="m">3</span><span class="o">:</span><span class="m">4</span><span class="p">,</span> <span class="m">2</span><span class="p">),</span> list<span class="p">(</span><span class="k-Variable">T</span><span class="p">,</span> <span class="k-Variable">F</span><span class="p">,</span> <span class="s">&quot;yes&quot;</span><span class="p">))</span>
v
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [[1]]
## [[1]][[1]]
## [1] 2
## 
## [[1]][[2]]
## [1] 4
## 
## [[1]][[3]]
## [1] TRUE
## 
## [[1]][[4]]
## [1] &quot;nope&quot;
## 
## [[1]][[5]]
## [1] 1 2 3 4 5
## 
## 
## [[2]]
## [1] 3 4 3 4
## 
## [[3]]
## [[3]][[1]]
## [1] TRUE
## 
## [[3]][[2]]
## [1] FALSE
## 
## [[3]][[3]]
## [1] &quot;yes&quot;
</code></pre>
</div>

<div class="highlight"><pre><code class="r">str<span class="p">(</span>v<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## List of 3
##  $ :List of 5
##   ..$ : num 2
##   ..$ : num 4
##   ..$ : logi TRUE
##   ..$ : chr &quot;nope&quot;
##   ..$ : int [1:5] 1 2 3 4 5
##  $ : int [1:4] 3 4 3 4
##  $ :List of 3
##   ..$ : logi TRUE
##   ..$ : logi FALSE
##   ..$ : chr &quot;yes&quot;
</code></pre>
</div>

<div class="highlight"><pre><code class="r">typeof<span class="p">(</span>v<span class="p">)</span>
</code></pre>
</div>

<div class="highlight"><pre><code class="text">## [1] &quot;list&quot;
</code></pre>
</div>

]]></content:encoded>
    </item>
    
    <item>
      <title>使用 Jekyll + knitr 发布博客</title>
      <link>http://williamlfang.github.com/cn/2014/01/24/shi-yong--rmarkdown--fa-biao-bo-ke/</link>
      <pubDate>2014-01-24T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/24/shi-yong--rmarkdown--fa-biao-bo-ke</guid>
      <content:encoded><![CDATA[<h2 id="section">我的博客之旅</h2>

<p>这些天一直都在钻研如何在博客中加入可以执行 <strong>R</strong> 程序代码的博客模板。我先前也有过写博客的经历，不过那时候使用的博客都是免费托管在其他的服务器中，一方面是缺乏可定制，大都是千篇一律的，无法满足「DIY」的需要，另一方面，也是主要的问题，这些博客网站很少有支持 <strong>LaTeX</strong> 的数学输出，对于数学环境的支持不尽人意。我也就偶尔在写一些纯文字类的随想，不曾涉及专业领域的事情。</p>

<p>后来我实在忍无可忍了，觉得找一个必须是支持 <strong>LaTeX</strong> 代码的博客网站。这也就只有在 <strong>WordPress</strong> 上了。我也尝试了使用一段时间。一开始发现还真是方便，直接使用 <strong>LaTeX</strong> 代码产生数学编译环境，如此一来便可以在上面多说点专业领域的话了。可是，后来我发现在 <strong>WordPress</strong> 上管理博客与修改模板是一件多么痛苦的事情，既需要更改模板，而且每次改完了发现不是自己想要的效果，又得重新再做。如此一来，光花费在博客网站的维护时间竟然占用了多数。如此不堪重负。</p>

<p>后来我开始尝试在使用  <strong>R</strong> 做统计分析，也陆陆续续的写了一些小程序。我的想法是，将 <strong>R</strong> 强大的数据分析与绘图能力与 <strong>LaTeX</strong> 超级优美的数学编辑水平结合一起，从而生成既有分析又有数据、既有文本又有图表的文档。后来发现这个想法别人早已实现，那就是 <code>Sweave</code>，支持在 <strong>LaTeX</strong> 使用 <strong>R</strong> 代码 （或者倒过来说，在 <strong>R</strong> 中使用 <strong>LaTeX</strong> 语法），并且直接输出结果。再后来，我接着发现这个原来还有『豪华升级版』，那就是我今天要给各位介绍的 <code>knitr</code>，一个更加强大的支持 <strong>LaTeX</strong> 编译环境的 <strong>R</strong> 软件包。</p>

<p>可是，有时候我不大喜欢 <strong>LaTeX</strong> 的一点在于，永远都需要那么复杂的插入代码环境，比如，当需要使用「强调」的时候，还得非常复杂而琐碎的键入 <code>\emph{}</code>，这个让我实在崩溃，因为毕竟我很多时候都是在使用纯文本输入，只是少数地方使用数学公式表达。那么，我想要的就是，需要强调了，就键入 <em>斜体强调</em>，或者 <strong>粗体强调</strong>。如此一来，写博客就非常的轻松了。</p>

<p>于是我在某个凌晨「毅然决然」的将博客编译语言再次转移阵地。这一次，我需要</p>

<ul>
  <li>简单：写博客就是写博客，随心所欲，没有多余的格式。在写作过程中，我仅仅需要关心文本，专注于思想表达。</li>
  <li>支持 <strong>R</strong> 代码，能够直接产生计算结果，插入图形。而且最好的是，别人看到这个代码还觉得不错，可以自己在电脑上重复输出结果。</li>
  <li>具有良好的定制特征，我可以根据个人偏好设置网页界面，并且需要很好的可持续维护性。</li>
  <li>最后是能够记录我在不同时间段写作的备份，方便随时「倒带」。这样我就不用担心删除当下文字段落后以后就找不回来，而且最好是告诉我具体的细节。</li>
</ul>

<h2 id="github--jekyll--knitr--rmarkdown">Github + Jekyll + knitr + Rmarkdown</h2>

<p>我就抱着这样的「苛刻要求」去找「谷哥」。出乎意料的是，竟然如此简单的就得到需要的解决方案了：</p>

<blockquote>
  <p>Github + Jekyll + Rmarkdown</p>
</blockquote>

<p>这是一个完美的方案！完全实现了我需要的多种服务：</p>

<ul>
  <li>
    <p><strong>Github</strong> 用于托管代码与博客。<strong>Git</strong> 是一款优秀的版本管理软件（VCS），由现在的 <strong>Linux</strong> 开发团队在维护。而 <strong>Github</strong> 就相当于一个网罗世界优秀程序员的「Facebook」，汇集了目前几乎所有的开源项目。</p>

    <p>现在，我可以通过将代码与博客托管到 <strong>Github</strong> 上，实现版本的系统检测，方便网站运行。</p>
  </li>
  <li>
    <p><strong>Jekyll</strong> 为我的博客网站提供了静态编译，将其打包为 <em>Html</em> 然后发布在托管的网站上。而且 <strong>Jekyll</strong> 提供了一系列的模板与模块，方便个人定制网站。与其他博客网站不同，经常动不动的就蹦出一个广告，<strong>Jekyll</strong> 编制的网站上面不会有多余的信息，我只陈列需要分享的内容。</p>
  </li>
  <li>
    <p>最后，就是 <strong>knitr</strong> 与 <strong>Rmardown</strong> 可以轻松的实现博客撰写。现在，我需要做的就是使用 <strong>Markdown</strong> 语法输入，然后在需要 <strong>R</strong> 的地方直接插入代码即可。一篇完整的博客就是我沿着自己的想法一路写到底，中间不会有其他的打扰，不要反复的插入格式命令。</p>
  </li>
</ul>

<h2 id="rmarkdown">使用 <strong>Rmarkdown</strong></h2>

<p>下面，我介绍一下如何实现将 <strong>R</strong> 代码编译为网页 <strong>Markdown</strong> 格式。由于 <strong>Jekyll</strong> 支持将 <strong>Markdown</strong> 编译成 <strong>Html</strong> 网页，因此，我们就可以很方便的将 <strong>R</strong> 文件编译成 <strong>Html</strong> 并发布到 <strong>Github</strong> 上面了。我主要参考了 Jason Bryer 的帖子， <a href="http://jason.bryer.org/posts/2012-12-10/Markdown_Jekyll_R_for_Blogging.html">“Using (R) Markdown, Jekyll, &amp; GitHub for a Website”</a>。另外，由于这个帖子生成的图片存储在同样一个文件夹下面，有时我想找某个博客的图片时，会非常的不方便。于是我对其做了一个小小的修改，将经过 <strong>R</strong> 产生的图片放在与帖子相对应的文件夹目录下，方便查找。比如，我有一个文档，<code>2014-01-24-shi-yong--rmarkdown--fa-biao-bo-ke.Rmd</code>，那么，图片的存放目录应该是</p>

<table>
  <tbody>
    <tr>
      <td>-dir</td>
    </tr>
    <tr>
      <td> </td>
    </tr>
    <tr>
      <td>-assets</td>
    </tr>
    <tr>
      <td> </td>
    </tr>
    <tr>
      <td>– images</td>
    </tr>
    <tr>
      <td> </td>
    </tr>
    <tr>
      <td>—- r-figures</td>
    </tr>
    <tr>
      <td> </td>
    </tr>
    <tr>
      <td>—– 2014-01-24-shi-yong–rmarkdown–fa-biao-bo-ke</td>
    </tr>
    <tr>
      <td> </td>
    </tr>
    <tr>
      <td>—— fig1.png</td>
    </tr>
  </tbody>
</table>

<h3 id="rmarkdownr">建立一个 <code>rmarkdown.r</code></h3>

<p>首先是在主目录(<code>_posts</code>)下面建立一个 <code>rmarkdown.r</code> 文件，用于执行编译功能。主要用途就是实现将当前目录下所有的带 <code>.Rmd</code> 文件转化为 <code>.md</code> 格式，从而可以实现发布。下面是其主要内容，也可以在<a href="/cn/_post/rmarkdwn.r">这里</a>下载。</p>

<pre><code>#' This R script will process all R mardown files (those with in_ext file extention,
#' .rmd by default) in the current working directory. Files with a status of
#' 'processed' will be converted to markdown (with out_ext file extention, '.markdown'
#' by default). It will change the published parameter to 'true' and change the
#' status parameter to 'publish'.
#' 
#' @param dir the directory to process R Markdown files.
#' @param images.dir the base directory where images will be generated.
#' @param images.url
#' @param out_ext the file extention to use for processed files.
#' @param in_ext the file extention of input files to process.
#' @param recursive should rmd files in subdirectories be processed.
#' @return nothing.
#' @author Jason Bryer &lt;jason@bryer.org&gt;
convertRMarkdown &lt;- function(dir=getwd(), images.dir=dir, images.url='/cn/assets/images/',
  						 out_ext='.markdown', in_ext='.rmd', recursive=FALSE) {
  	require(knitr, quietly=TRUE, warn.conflicts=FALSE)
  	files &lt;- list.files(path=dir, pattern=in_ext, ignore.case=TRUE, recursive=recursive)
  	for(f in files) {
  		message(paste("Processing ", f, sep=''))
  		content &lt;- readLines(f)
  	frontMatter &lt;- which(substr(content, 1, 3) == '---')
	  if(length(frontMatter) &gt;= 2 &amp; 1 %in% frontMatter) {
		  statusLine &lt;- which(substr(content, 1, 7) == 'status:')
  		publishedLine &lt;- which(substr(content, 1, 10) == 'published:')
	  	if(statusLine &gt; frontMatter[1] &amp; statusLine &lt; frontMatter[2]) {
		  	status &lt;- unlist(strsplit(content[statusLine], ':'))[2]
  				status &lt;- sub('[[:space:]]+$', '', status)
  			status &lt;- sub('^[[:space:]]+', '', status)
	  		if(tolower(status) == 'process') {
		  		#This is a bit of a hack but if a line has zero length (i.e. a
			  	#black line), it will be removed in the resulting markdown file.
				  #This will ensure that all line returns are retained.
				content[nchar(content) == 0] &lt;- ' '
	  			message(paste('Processing ', f, sep=''))
		  		content[statusLine] &lt;- 'status: publish'
			  	content[publishedLine] &lt;- 'published: true'
				  outFile &lt;- paste(substr(f, 1, (nchar(f)-(nchar(in_ext)))), out_ext, sep='')
  					render_markdown(strict=TRUE)
  				opts_knit$set(out.format='markdown')
	  			opts_knit$set(base.dir=images.dir)
		  		opts_knit$set(base.url=images.url)
  					##
  				## 产生的图片存储位置 `/assets/images/r-figures/`
	  			fig.path &lt;- paste0("r-figures/", sub(".Rmd$", "", basename(files)), "/")
		  		opts_chunk$set(fig.path = fig.path)
			  	## opts_chunk$set(fig.cap = "center")  ## figure position
			    render_jekyll()     
				  ##
  					try(knit(text=content, output=outFile), silent=FALSE)
  				} else {
  					warning(paste("Not processing ", f, ", status is '", status, 
  								"'. Set status to 'process' to convert.", sep=''))
  				}
  			} else {
  				warning("Status not found in front matter.")
  			}
  		} else {
  			warning("No front matter found. Will not process this file.")
  		}
  	 }
  	 invisible()
 }
</code></pre>

<h3 id="rmdsh">建立可执行文本 <code>rmd.sh</code></h3>

<p>这个 <code>rmd.sh</code> 也是存放在目录 <code>_posts</code>, 主要就是</p>

<ul>
  <li>
    <p>识别当前的目录，并将其赋予 <code>dir</code> 参数</p>
  </li>
  <li>
    <p>默认在 <code>Terminal</code> 运行 <code>rmakrdown.r</code> 的 <code>convertRmarkdown</code> 函数，并输出经过转化的 <code>.markdown</code> 文件。</p>
  </li>
</ul>

<p>文本 <code>rmd.sh</code> 可以<a href="/cn/_post/rmd.sh">下载</a>，里面内容是</p>

<pre><code>DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &amp;&amp; pwd )"
Rscript -e "source('$DIR/rmarkdown.r'); convertRMarkdown(images.dir='../assets/images')"
</code></pre>

<h3 id="yaml-">添加 <code>YAML</code> 标头</h3>

<p>最后，我们需要在 <code>.Rmd</code> 文件标头添加以下命令：</p>

<pre><code>published: false
status: process
</code></pre>

<p>这个是因为：</p>
<blockquote>
  <p> - First, the published parameter should be set to false so that Jekyll will not attempt to process the file. The convertRMarkdown function will change this parameter to true in the resulting Markdown file. </p>
  <p> - The second parameter, status, must be set to process for the convertRMarkdown function to convert the file. This is useful when working a draft of a document and you wish to not have the file converted. </p>
</blockquote>

<h3 id="mathjax"><strong>MathJax</strong></h3>

<p>如果想要让 <strong>Jekyll</strong> 支持数学公式，我们还需要添加插件，<strong>MathJax</strong>，然后使用 *markdown** 的编译设置为 <strong>kramdown</strong>。我是这样配置的</p>

<h4 id="kramdown">添加 <strong>kramdown</strong></h4>
<p>由于我先前使用的是 <em>rdiscount</em> 来编译 <strong>mardown</strong> 语法，不能够支持对数学公式的输出。使用的替代是 <strong>kramdown</strong>，一个更加强大的插件，支持 <em>pdf</em>， <em>html</em>，<em>LaTeX</em> 等格式的转化。</p>

<ul>
  <li>
    <p>首先是在主目录文件夹找到 <code>_config-yml</code> 打开，将 <strong>markdown</strong> 默认的编译设置为 <strong>kramdown</strong>。</p>
  </li>
  <li>
    <p>在 <code>_layout</code> 目录下面有 <code>default.html</code> 的页面设置，我们需要在 <code>&lt;head&gt;</code> 与 <code>&lt;/head&gt;</code> 之间插入代码
<img src="/cn/assets/images/r-figures/2014-01-24-shi-yong--rmarkdown--fa-biao-bo-ke/snapshot1.png" alt="snapshot1.png" /></p>

    <p>也就是在网页开启前使用 <strong>MathJax</strong> 进行编译，支持对数学的输出。这里，我使用单个美元符号 <code>$</code> 与 <code>$</code> 输入 <strong>LaTeX</strong> 代码，会在网页显示相应的 <em>行内公式</em>，而使用一对的美元符号 <code>$$</code> 与 <code>$$</code> 来输入行间数学公式。</p>
  </li>
</ul>

<h3 id="section-1">例子</h3>

<h4 id="section-2">数学公式</h4>

<p>比如我只需要如下输入数学公式，$S = \sum_{i=1}^k x_i$，或者是<script type="math/tex">a^2 + b^2 = c^2</script></p>

<script type="math/tex; mode=display">\frac{1}{\pi}=\frac{2\sqrt{2}}{9801}\sum_{k=0}^\infty\frac{(4k)!(1103+26390k)}{(k!)^4396^{4k}}</script>

<script type="math/tex; mode=display"> \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} = 1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}} {1+\frac{e^{-8\pi}} {1+\ldots} } } } </script>

<script type="math/tex; mode=display">% <![CDATA[

\begin{align}
\mbox{Union: } & A\cup B = \{x\mid x\in A \mbox{ or } x\in B\} \\
\mbox{Concatenation: } & A\circ B  = \{xy\mid x\in A \mbox{ and } y\in B\} \\
\mbox{Star: } & A^\star  = \{x_1x_2\ldots x_k \mid  k\geq 0 \mbox{ and each } x_i\in A\} \\
\end{align}
 %]]></script>

<h4 id="r"><strong>R</strong></h4>

<p>再者，这个 <code>R</code> 代码，我们可以直接生成图片。</p>

<div class="highlight"><pre><code class="r">x <span class="o">=</span> rnorm<span class="p">(</span><span class="m">100</span><span class="p">)</span>
plot<span class="p">(</span>density<span class="p">(</span>x<span class="p">))</span>
</code></pre>
</div>

<p><img src="/cn/assets/images/r-figures/2014-01-24-shi-yong--rmarkdown--fa-biao-bo-ke/fig1.r-figures/2014-01-26-data-structure/fig1.png" alt="plot of chunk fig1" /> </p>

]]></content:encoded>
    </item>
    
    <item>
      <title>Advanced R Programming</title>
      <link>http://williamlfang.github.com/cn/2014/01/20/r-note/</link>
      <pubDate>2014-01-20T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/20/r-note</guid>
      <content:encoded><![CDATA[<p>这个文档记录了我在学习 <a href="http://had.co.nz/">Hadley Wickham</a> 即将出版的新书，<a href="http://adv-r.had.co.nz/">Advanced R Programming</a> 时的一些笔记与总结，以便将来复习查阅。该书博大精深，结构严谨，涵盖面广泛，涉及几乎目前有关「R」的所有问题。从最基础的数据结构开始讲起，然后逐步渐进到如何编写针对问题的 <code>function</code>，再进阶到如何开发能够发布以供他人使用的 <code>package</code>。Wickham 本人就是在「R Community」团体中的传奇人物，开发了许多为人称道的宏包，如 <code>ggplot2</code>等。而本书真是作者在总结了近十年的 「R」软件开发后编写的一本巨著。仔细深入阅读此书必将受益匪浅，极大的提升我们使用与开发「R」的各项技能，真正从最底层去认识「R」这个当今最强大的数据处理、统计分析与图形可视化编程语言。</p>

<p>正如他自己所说的：</p>

<blockquote>
  <p>I have been programming in R for over 10 years, spending a lot of time trying to figure out how the language works. Not everyone has the luxury of spending years to understand a programming language, so this book is my attempt to help you to become an effective R programmer as quickly as possible. By reading this book, you will avoid the many mistakes that I made and the many dead ends that I got stuck in, and quickly navigate your way to useful tools and techniques. Although R has its frustrating quirks, I truly believe that at its heart lies an elegant and beautiful language, well tailored for data analysis and statistics. In this book, I’ll do my best to reveal that language to you, helping you to understand powerful idioms that allow you to attack many types of problems.</p>
</blockquote>

<h2 id="why-r">Why 「R」</h2>

<p>对于这个问题的回答，最简短的回答是</p>

<blockquote>
  <p>多学一门编程语言总不会死吧？！！！</p>
</blockquote>

<p>确实，在当今这个互联网与信息时代，我们的生活与工作与电脑紧密相连、形影不离，如果要想了解这个时代、这个世界，我们首先必须先了解那些控制与主宰了我们生活节奏的「电脑们」是如何「生活」的。进一步说，即那些操控了「电脑们」的<strong>「程序」</strong>是如何运行的。而所谓的「程序」，终归到底，是「程序语言」（Programming language）。前几年流行的一本「Hakers and Painters」就在序言开宗明义地说：</p>

<blockquote>
  <p>Everything around us is turning into computers. Your typewriter is gone, replaced by a computer. Your phone has turned into a computer. So has your camera. Soon your Tv will. Your car was not only designed on computers, but has more processing power in it than a room-sized mainframe did in 1970. Letters, encyclopedias, newspapers, and even your local store are being replaced by the Internet.</p>
</blockquote>

<p>因此，我们要想了解世界，就必须先懂得这个世界在说什么（编程）「语言」。所谓「技多不压身」，多学习一门「编程语言」也促使我们从另外一个角度看世界，多一种批判的眼光，多一层思维的觉悟。何乐而不为？</p>

<p>当然，如果你是首次听说/接触「R」，对这个编程语言一点冲动的想法都没有，那我就需要找各种<em>理由</em>来劝说你「是时候该学习『R』了」，哪怕是对阅读统计报告的需要。</p>

<p><em>注意</em>：真是下面的几条<em>Reasons</em>把我拉入了「R」介个广大的「神教」中，有幸或不幸，我也希望你来加入！</p>

<ul>
  <li>
    <p>「R」是处理统计数据与图形可视化的「神器」，能够高效的完成各种数据分析，生成信息充实而页面精美的图形。一方面，我们可是直接使用现今已有的软件包（通过<code>install.packages("")</code>)，涵盖了从基本的统计分析方法，如计算均值，方差分析，到时下最前沿的统计方法，可用于处理有关统计建模、机器学习、大数据管理等问题;另一方面，如果发现现有的软件包不能满足或者不适合手头问题的解决，那么我们还可以自己动手开发。这个特性赋予了「R」强大的处理数据的能力。</p>
  </li>
  <li>
    <p>「R」是一款<strong>自由的开源软件体</strong>。这意味着你有权限去获取、使用、修改甚至是发行任何版本的「R」程序。这一点对于使用<code>Windows</code>的用户可能不会意识到有多重要，因为在国内的环境中，我们从来都没有关心过一款软件的「版权」问题，心想着反正上网有大量的破解软件可供下载使用。可是对于一个合格的哪怕只是刚入门的「Geek」来说，我已经不能再忍受破解（=盗版=病毒）软件的荼毒。从网上某处下载的软件，总是神乎其神的在某个地方给你添加插件，修改管理者权限，安装不必要也不想要的软件。然后在某天开机之后，屏幕变黑，系统变坏，情绪变糟。</p>

    <p>后来我开始转移阵地到「Linux」，开始慢慢接触开源项目，才逐渐领会到开源软件带来的自由。比如，我可以从互联网以「正当理由」、「合理方式」获得所需的软件，并能够在尊重原开发者的情况下修改软件，生成「私人定制」，我甚至还可以将其发布到网上供他人使用。涉及到软件的自由是多层次的，其中最基本的一条就是，我可以修改、进一步开发以利解决问题。</p>

    <p>「R」就是这么一个软件，她给你所需，为你所用，助你之力。</p>

    <p>同时，「R」的开源特性也意味着这是一个免费的软件，我们可以以零成本的价格使用。这对于一枚「学生党」，有着「千情万钟」的诱惑（刨去破解软件）。</p>
  </li>
  <li>
    <p>分散在世界各地的「R Community」为这个编程语言持续地注入新鲜的生命力，使之长久延续。我们可以到「CRAN」、<a href="https://stat.ethz.ch/mailman/listinfo/r-help">R-help mailing list</a>、<a href="http://stackoverflow.com/questions/tagged/r">StackOverflow</a>寻求帮助，也可以通过当地的「R user group」来咨询方案。不同与其他的编程语言，「R」的开源共享的属性让她得到世界各地用户的偏好，共同开发以保持其活力。我们无需担心哪一天自己辛苦学习与使用的编程语言/软件就撒手不干停止更新服务了。因此，学习「R」几乎是一个「零（违约）风险」的投资。</p>
  </li>
  <li>
    <p>可重复（reproducable）研究指得是在现有的数据框架下，我们可以通过复制原来研究成果的代码来验证其准确性。这区别于更加广泛意义上的可复制（replecated）研究，即需要重新收集数据样本来复制结果。可重复研究允许我们在有限的经费预算约束下，极大可能的验证科学研究成果。</p>

    <p>「R」正是开发可重复研究的利器，提供了像<code>knitr</code>这样优秀的软件包，使得统计分析的任何一个过程都可以通过运行代码来检验研究成果。同时，我们还可以在文章正文中「植入」程序代码，直接计算结果（面向对象，object-oriented）、绘制图形（ggplot2）、编制表格（tabular，xtable）。这省去了传统的撰写文章的麻烦与琐碎。比如，原先我们可能是在「LaTex」中写入论述，等到了需要使用图形的地方，需要事先标明<code>\includegraphic{}</code>，然后通过查找对应的图片插入。这期间被各种「烦文缛节」、各种「黑暗技巧」搞得晕头转向、不知何处。最后搞不好还弄错了文字与图形的匹配。而这些统统在<code>knitr</code>中可以自动完成，我们需要的，就是顺着思维的路线一路走下去，该说人话的时候就写人话，该使用机器语言就直接健入代码产生需要的结果或者图形。真可谓</p>
  </li>
</ul>

<blockquote>
  <p>「R」与「LaTex」齐飞，思想代码共一体。</p>
</blockquote>

<ul>
  <li>
    <p>此外，「R」还是一个<em>跨平台</em>的软件体，通吃「三界」：</p>

    <ul>
      <li>Windows系统可以直接点击<code>.exe</code>软件来安装;</li>
      <li>
        <p>Linux系统使用命令安装：</p>

        <pre><code> sudo apt-get install r-base r-base-dev
</code></pre>
      </li>
      <li>Mac系统。（抱歉，我没有使用Mac，故此处不敢高声语。）</li>
    </ul>
  </li>
</ul>

<h2 id="why-not-r">Why <em>Not</em> 「R」</h2>

<p>对于这个问题，我真的不知该如何回答。如果说以上的几点理由还不够具有「杀伤力」，那在下也只能自愧功力不够、道行尚浅、修行有限。</p>

<p>不过还好，大神来帮忙了：</p>

<blockquote>
  <p>Of course, R is not perfect. R’s biggest challenge is that most R users are not programmers.     </p>
</blockquote>

<p>他给出的批评无非是「double-edged sword」，所谓凡是有利有弊、一正一邪。各位看官可以到大神的网上去找找不使用「R」的「牵强附会」的理由。在下无需多言，只不过再此累赘一下，也算是个人当初的体会。</p>

<p>「R」的学习曲线太陡峭、成本太高了。也就是说，对于一个初学者来说，「R」的代码几乎可以说是「摧枯拉朽」、「灭顶之灾」的。原因有二：</p>

<ul>
  <li><strong>R</strong> 掺杂了其他语言的使用，如<strong>C</strong>，<strong>Python</strong>。这旨在提高「R」的运行速度与计算能力，增强数据分析。不过这对「beginner」却造成了困扰。</li>
</ul>

<blockquote>
  <p>我的建议是：既来之，则安之。一开始看不懂没关系，先试着挑-「好看」的来，然后再进一步深入学习。等到你真正需要扩展的时候，再去找些资料学习就可以了。</p>
</blockquote>

<ul>
  <li><strong>R</strong> 对于编写程序没有过于严格的要求，是真正意义上的「注重结果」的编程语言。这直接造成了「恶劣影响」，导致许多的代码行都不大注重严谨，缺乏统一。看不懂别人的代码那是必须的，有时甚至都看不懂自己以前写的代码了。,,Ծ‸Ծ,,</li>
</ul>

<blockquote>
  <p>推荐：多看多看多看！没见过猪跑也好歹有吃过猪肉。另外，可以看看一些「guide」，养成良好的编写程序的习惯，比如，大神的<a href="http://adv-r.had.co.nz/Style.html">建议</a>,以及<a href="http://google-styleguide.googlecode.com/svn/trunk/Rguide.xml">Google’s R Style Guide</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>WineQQ2013 可以使用</title>
      <link>http://williamlfang.github.com/cn/2014/01/18/qq-for-linux/</link>
      <pubDate>2014-01-18T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/18/qq-for-linux</guid>
      <content:encoded><![CDATA[<h2 id="qq-for-linux">QQ for <code>Linux</code></h2>
<p>想要在Linux操作系统下使用 <code>QQ</code> 真的得费不少劲。我之前尝试通过 <code>WINE</code> 来安装 <code>QQ2013</code>，可是最终以失败结束。</p>

<ul>
  <li>
    <p>一方面是由于目前的 <code>WINE</code> 技术还不是很好，对于一些商业软件支持力度不够，也不能完全模拟 <code>Windows</code> 系统来安装 <code>.exe</code> 的软件（如果完全取代了，怎么感觉又回到 <code>Windows</code> 时代了呢…..），期间需要不停的下载相关而不必要的软件，大费人力与（电）脑力，而且终归落得个不能使用/中文乱码的惨淡结局。</p>
  </li>
  <li>
    <p>另一方面，<code>Tencent</code> 公司也不会完全放弃 <code>QQ</code> 的商业价值来满足开源爱好者的，他们满眼看到的是商业利益。<code>QQ</code> 本身是一个具有黑暗魔法力量的软件，可以推送广告取得收入，可以不间断的搜索用户资料（先前有 3Q 大战及由此来），还能维护一个庞大的软件生态链。故此，虽然曾经有一段时间的 <code>QQ for Linux</code> 的美好光景，却也一去不复返。</p>
  </li>
</ul>

<p>我们现在想要在 Linux 上使用 <code>QQ</code>，真可谓“斗智斗勇”，方能取得一丁点的成就。</p>

<h2 id="qq">虚拟机下使用 QQ</h2>
<p>我之前有在一篇关于虚拟机 <a href="http://williamlfang.github.io/cn/2014/01/04/virtualbox/">virtualbox</a> 的文章中谈过可以利用虚拟机来运行 <code>Windows</code> 操作系统，并在其使用 <code>QQ</code> 等软件。可以，这也很不方便，为了使用一个软件大开虚拟机占用大量的内存，实属不值，何况对于一些老机子更是苦命。因此，我决定放弃这个既浪费资源又不讨好的想法，另辟蹊径。</p>

<h2 id="wineqq">WineQQ</h2>
<p>目前，由一个叫做 “LongeneTeam” 团队给广大的用户带来了福音。他们号称开发了史上最牛叉的、能够在 Linux 系统运行的 <code>wineQQ</code>。其工作原理是：
&gt; 通过以deb的格式将 QQ 软件、Wine基本配置、有关字体以及一些必要的配件统统打包好，这样用户可以直接点击deb文件来安装、使用 QQ。</p>

<p>目前 wineQQ 的最新版本为 <a href="http://www.longene.org/forum/viewtopic.php?t=4700">wine-1.7.9</a>。deb格式的软件可以在<a href="http://pan.baidu.com/s/1hq83fWo">这里</a>或者<a href="http://www.longene.org/download/WineQQ2013SP6-20140102-Longene.deb">这里</a>下载到。之后可以直接双击打开，经由 <code>Software Manager</code> 确认系统密码后即可安装。完成之后在找到 <code>QQ</code> 打开即可。
<img src="/cn/assets/images/QQ/qq.png" alt="wineqq2013" /></p>

<h2 id="section">问题之门及解决之道</h2>
<p>以下汇集了我在使用 wineQQ2013 过程中遇到的一些问题，以及相应的解决方法。欢迎补充。</p>

<h3 id="section-1">64位操作系统不能运行</h3>
<p>这个问题主要是由于原先只是在32位系统运行的 <code>wineQQ</code> 需要安装配件。如下：</p>

<div class="highlight"><pre><code class="bash"><span class="lineno">1</span> sudo apt-get install libc6-i386 
<span class="lineno">2</span> sudo apt-get install ia32-libs
</code></pre>
</div>

]]></content:encoded>
    </item>
    
    <item>
      <title>Images</title>
      <link>http://williamlfang.github.com/cn/2014/01/18/img/</link>
      <pubDate>2014-01-18T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/18/img</guid>
      <content:encoded><![CDATA[<p>This thread will show you how to add a new images in Markdown through <code>relative path</code>.</p>

<ol>
  <li>
    <p>Make sure that you have already set the <code>url</code> correctly as <code>williamlfang.github.com</code>.</p>
  </li>
  <li>
    <p>Now that we wanna to add new images in the website as <code>williamlfang.github.com/cn</code>, which is a <code>gh-pages</code>. Unfortunely, all the <code>url</code> links are directed to the main repo <code>williamlfang.github.com</code> instead of the <code>williamlfang.github.com/cn</code>. This is what the following to be utilized.</p>
  </li>
  <li>
    <p>Suppose you have created a relative path containing folder as <code>assets/images/btt.png</code>, all you need to do is to add the additional prelix <code>/cn</code> alongsie the relative file path <code>assets/images/btt.png</code>. See below as as example: </p>
  </li>
</ol>

<div class="highlight"><pre><code class="bash">!<span class="o">[</span>bottom<span class="o">](</span>/cn/assets/images/btt.png<span class="o">)</span>
</code></pre>
</div>

<p>which gives
<img src="/cn/assets/images/btt.png" alt="bottom" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Linux Mint 安装 Pandoc</title>
      <link>http://williamlfang.github.com/cn/2014/01/16/pandoc/</link>
      <pubDate>2014-01-16T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/16/pandoc</guid>
      <content:encoded><![CDATA[<h2 id="linux-mint--pandoc">下面介绍在 Linux Mint 系统下如何安装 pandoc。</h2>

<ol>
  <li>
    <p>如官网介绍，安装 pandoc
 sudo apt-get install cabal-install
 cabal update
 cabal install pandoc</p>
  </li>
  <li>
    <p>添加路径，
 sudo gedit /etc/profile
  在打开的文档最后输入
 export PATH=/home/william/.cabal/bin:$PATH
  再到 
 cd /etc/
 source profile</p>
  </li>
  <li>
    <p>再次重新
 cabal install pandoc pandoc-citeproc</p>
  </li>
  <li>
    <p>查看是否安装成功
 pandoc –version</p>
  </li>
</ol>

]]></content:encoded>
    </item>
    
    <item>
      <title>Linux 中文输入法（fcitx）安装与设置</title>
      <link>http://williamlfang.github.com/cn/2014/01/08/chinese-input/</link>
      <pubDate>2014-01-08T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/08/chinese-input</guid>
      <content:encoded><![CDATA[<p>Linux （Mint，16 Petra）系统本身并没有默认安装中文输入法。为了在 Linux 操作系统下使用中文输入，需要自己添加。我倒腾了大半天的，终于明白过来这是怎么设置了。现在将全部的过程记录在下面，以备日后使用。</p>

<ol>
  <li>
    <p>首先是安装源，</p>

    <p>sudo add-apt-repository ppa:fcitx-team/nightly</p>
  </li>
  <li>
    <p>更新</p>

    <p>sudo apt-get update</p>
  </li>
  <li>
    <p>安装 fcitx，搜狗输入法，五笔（一般不用），以及双拼</p>

    <p>sudo apt-get install fcitx fcitx-sogoupinyin fcitx-table-wubi fcitx-pinyin</p>
  </li>
  <li>
    <p>这个比较重要，可以先在终端输入 fcitx，看看是不是提示没有可用的前端，则需要安装如下 <code>fcitx-frontend-gtk3</code></p>

    <p>sudo apt-get install fcitx-frontend-gtk3 fcitx-ui-classic</p>
  </li>
  <li>
    <p>打开 fcitx config，如果提示 “fcitx 的 KCModule 未被找到 缺少”，则在Terminator输入</p>

    <p>sudo apt-get install kde-config-fcitx</p>
  </li>
  <li>
    <p>在 <code>fconfig</code> 设置输入法即可使用。</p>
  </li>
  <li>
    <p>需要在 <code>/home</code> 文件夹下面新建/修改 <code>.xprofile</code></p>
  </li>
</ol>

<blockquote>
  <p>export LC_ALL=zh_CN.utf8        <br />
export XMODIFIERS=@im=fcitx        <br /> 
export QT_IM_MODULE=xim        <br />
export GTK_IM_MODULE=xim        <br /> 
fcitx -d        <br /></p>
</blockquote>

]]></content:encoded>
    </item>
    
    <item>
      <title>新系统的第一个软件</title>
      <link>http://williamlfang.github.com/cn/2014/01/05/goagent/</link>
      <pubDate>2014-01-05T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/05/goagent</guid>
      <content:encoded><![CDATA[<p>最近由于电脑不是很稳定,装了几次系统.这个我之前也有谈过,如何从万恶的 MS 的 Windows 系统成功<a href="http://williamlfang.github.io/cn/2014/01/window-2-linux/">转型</a>到自由软件与操作系统 Linux.经过这几次的装机经历,我也发现了这其中的一些pattern.比如,我今天要谈到的话题:
&gt; 谁是你的新系统的第一个软件呢?</p>

<p>对于这个问题的回答,估计该是千奇百怪的吧.对于典型的程序员,可能是先装一个 git, 然后在 <em>Emacs</em> 下积极的编程.而对于一个游戏痴迷者,大概是某个武器装备吧.而对于我,在多次的装机之后,无一例外的,(竟然)!均是安装了 <a href="https://code.google.com/p/goagent/">GoAgent 科学上网神器</a>.</p>

<p>关于<em>科学上网</em>,此处不必多言,如果诸君想要一窥究竟,可以在google上找找.我想说的是,为什么,这个普通的<em>翻墙</em>工具,会成为新系统的第一位”业主”.</p>

<h2 id="section">我的青春旁白</h2>

<p>我向来愚钝,对于一些词汇,总是不能辨识.比如,这个词汇,”中国梦”.我一直不曾明白过,大概也不会明白了.</p>

<p>高中时,我怀疑自己有病.而且不仅仅是”我怀疑”这个初诊判断,我的老师也是这么认为的,说白日梦是一种病,得治,年轻人不要整天想着拯救世界红旗插遍美帝.可是,我当时就是这么一种精神状态,以为可以三年高考五年大学三年赶英五年超美,然后世界和平世态安定世人均等,我也可以冲着某某领导某某”长”(音,zhang,上声,意同高大上伟光正,异于短)说,这tm谁呀,我哥们.</p>

<p>然后我就被老师提着耳朵连打带骂赶鸭上架赶驴赴约般拜见心理医生.我说,医生,我有病,心里的.他贼兮兮的看着我说,没症状,不是心里的,是脑子的病.专业术语曰”心理”.我说,那就是呀,我有病,心里的.他说,不对,你心里的,没有病,你心理的,有病.</p>

<p>我说,那我心里的到底有没有病呢.他说,你心里的没有病,可是你心理的有病.</p>

<p>我们就这样争吵了一个下午.彼此都忘了最开始的症结.原来的我是会做白日梦的,原来的我是会有堂吉诃德的烦恼的维特的追忆似水流年的普鲁斯特的情人在敲打铁皮鼓的令人愉悦的忧伤的.可是那个下午过后,我像是决意要长大的奥斯卡,毅然丢弃了心爱的铁皮鼓,毅然开始乐观向上开始做一颗好的种子好的花朵好的公民.我的梦丢了,可是我的病也好了.</p>

<p>这个诊断报告一直保护了我走过三年的高中.因为有了它,我有病就像我的白日梦一样就成了一个历史一个过去一个不能遗忘的以往,而我没病给我保护给我遮羞布给我得以进入那个浩浩大学给我得以存活于这个泱泱大国.</p>

<p>多年后,我一直以为,梦是一种病,而且是一种叫做心理的病.对于这一点,当初还是非常学究范非常书生气的我查找了诸多名家,诸多著作.我还一副洗耳恭听卑躬屈膝的写笔记做总结.可是我满眼看到的,是有关梦的病与关于病的梦的论述,是有关身体健全心智不全躯体安康心理黯然刻画,是有关自由意志如何被独裁奸污被专断纳妾的记录.那时候,我有那么一个片段,回到过去那个有病的年代,回去那个到了要治病的年代,对着他们歇斯底里也罢痛哭流涕也罢,求求你们,放过那个孩子.他有病,可是真的不需要治.</p>

<p>对于这样一种类似没病的有病,”中国梦”最直观的解释,就是大家都回青春去,重走青春路.就像当年的有病的我,大家一起在做白日梦.以前我在学校里有病,因为白日梦在当初是属于疑难杂症乱象丛生,即使我背着老师偷偷溜进学校那个仅有的半个平方的播音室里,有点科普有点可笑向全校师生介绍F的梦的解析,可是他们依然不懂.至少我得到的惩罚告诉我他们不懂.他们说,这是一种病,一种臆想的病.</p>

<p>而现在,当我毅然学着当年那个书生学究的模样,想要研究”中国梦”之时,早已有伟大的教授与伟哥的叫兽在申请课题在申报遗迹.我想要试着研究者病一样的梦与梦一样的病,于是,我开始了在互联网的漫长冲浪在无人旷野的漫长流浪.</p>

<h2 id="section-1">我的互联网空白</h2>

<p>这个时代据说是”一个言论与集社自由”的好时代,我们在享受着犹如”忍者神龟”一般”龟网速”的同时,还在享受着天朝给予的各种”保护”.比如,某天有个小小的病毒侵入你的电脑,WOW,我们立马就有了防火墙的提醒,并在不知不觉中将其隔离,将其粉碎.此乃一劳永逸,不再整天提醒吊胆.再比如,某天你溜了个神,觉得是不是应该看看nyt整天都在评论神马玩意.于是,冒着被病毒侵入的危险,顶着被审查的暴风,你胆颤心惊而又小心翼翼的在你那个多年前早就不曾更新换待的IE浏览器输入一下符号</p>

<pre><code>http://www.nyt.com
http://www.facebook.com
http://www.twitter.com
</code></pre>

<p>叮咚….恭喜你,没有被电脑病毒侵入….因为有我们这个时代最伟大的软件设计–GFW的保护.你的一颗悬而又悬的心终于安定了.O(∩_∩)O哈哈~.你暗自庆幸着.原来无国外的网站竟然都一窝si的是病毒,善哉,善哉,多亏不曾打开过,多谢不曾浏览过,多喜没有腐蚀过…</p>

<p>很抱歉,我也曾今是众多号称是全球最庞大群体的”你”当中的一个,我也曾今为了侥幸躲过所谓”病毒与不良信息”的腐蚀而暗地窃喜过,我也曾今在茶余饭后有事没事的诅咒过那些有事没事天天设计所以”不良信息”的”美帝”,我也曾经在这有限的土地上观望这有限的雾霾幻想着无限的美梦得到无限的实现,我也曾经……</p>

<p>如果人为回首过去的无知而羞愧,那么,我愿永远的停留这个状态,在这千万中可能中的一个实现.因为过去的无知,足以让我愧对先贤的智慧,愧对自我的审判.</p>

<p>有一天,我也想多说的你一样,在心惊胆颤心跳提速心率不齐的情况下,打开了一个网页,也打开了一扇通往未知无限境地的危险抑或一扇引我走进更广阔苍穹的视窗.这一次,多亏那些大叔大”审”们的慷慨与仁慈,多谢在这一刻种种可能迹象中的一个处理随机过程实现的状态,一个不知天高地厚一个不通天朝美梦的孩子,在懵懵懂懂与莽莽撞撞间,如同童话里的爱丽斯之于仙界,我也来到了一个未知与未来的世界.</p>

<h2 id="section-2">我的自由独白</h2>

<p>传世纪之初,上帝说,要有人,于是世界多了亚当与夏娃.</p>

<p>我自知神力不比上帝,却也斗胆在互联网之初,说,要有自由,要有万能的自由.</p>

<p>可是,这个世界依然没有自由.因为他们如同一群奔跑在困境当中的野兽,争取着解放全世界,却最终挣扎着躺倒在猎人的枪口下.在有光之前,世界是黑的.在有互联网之后,自由便死光了.所有这个盛产网民的社会也盛产”黑客”.</p>

<p>我该感谢这些”黑客”,是他们让我看到原来世界是有光的.他们是谁,我不知道.我们彼此不曾谋面,也就省了在人潮拥挤的地铁站见着面隔着口罩相互寒暄.我们从来不打招呼,我们也从来不打群架,因为这个世界有很多的问题靠暴力与强拆是解决不了问题的,有很多的自由,越是抗争,越是抗取,越是早衰,越是早死.</p>

<p>后来,我也只是默默的躲进小楼,躲在小角,偶尔透过残留余光的视网膜,看看这个世界.</p>

<p>有些时候,我会通过goagent联系多年失散的朋友,在fb上看看近照是不是瘦了胖了高了怎么有人还矮了呢,在tw里也会想念那些远在天边的切切私语遗忘在某个不知名的接到.他们如同失落天涯的蒲公英,飘零在荒无管制的原野.可我却一直羡慕着羡慕着,唯独恨我这落地生根了的躯干,不远不近,囚禁在这无形的地牢里,守着这有形的长城,过着无期的日子,叹一口无尽的哀怨.</p>

<hr />
<p>### 附录:GoAgent设置说明
—-
GoAgent 为在天朝上网提供了一个小小的洞眼，让被墙的我们得以窥见外面自由的世界。</p>

<p>以下设置为个人经验,请谨慎借用.</p>

<ol>
  <li>
    <p>创建 <a href="https://appengine.google.com/">Google Appengine</a> 的ID.一个ID每天上限流量为1GB,最多可以申请10个账号.这样就可以保证一天内有10GB的流量可供使用,基本能够保证一天的上网需要,看个Youtube或者浏览Facebook是没问题的.如我的
&gt; williamfang01|williamfang02|williamfang05|williamfang06|williamfang07|williamfang08| <br />
&gt; williamfang09|williamfang1988|williamfang1989|williamlianfang</p>
  </li>
  <li>
    <p>下载 <a href="https://developers.google.com/appengine/downloads?hl=zh-cn">Google App Engine SDK</a>,并解压到一个 <code>/Goagent/go_appengine</code> 的文件夹下面.</p>
  </li>
  <li>
    <p>下载 <a href="https://code.google.com/p/goagent/">GoAgent</a>,将其解压到 <code>/Goagent/go_appengine</code>.</p>
  </li>
  <li>
    <p>打开 <code>/Goagent/go_appengine/goagent-goagent-37d13a7/local/proxy.ini</code>,在 <code>appid</code> 中输入刚才申请的 ID 账号,保存.</p>
  </li>
  <li>
    <p>打开 Linux 终端机,填写ID,gmail密码,上传账号信息.
&gt; cd /home/william/Programs/Goagent/go_appengine/goagent-goagent-37d13a7/serve    <br />
&gt; python uploader.zip</p>
  </li>
  <li>
    <p>成功后会有提示,回车推出.</p>
  </li>
  <li>
    <p>现在可以到 <code>/local</code> 下打开 <code>goagent-gtk.py</code>,直接运行即可上网.也可以将其复制到桌面,以后直接双击即可.</p>
  </li>
  <li>
    <p>在 chrome 中的配置.
&gt;+ 首先是通过 chrome store 安装 proxy
&gt;+ 点击设置,上传 <code>/local/SwitchyOptions.bak</code>
&gt;+ 点击 chrome 的 setting, 安装证书 <code>/local/CA</code>.</p>
  </li>
</ol>

]]></content:encoded>
    </item>
    
    <item>
      <title>在 Virutalbox 环境下安装虚拟机</title>
      <link>http://williamlfang.github.com/cn/2014/01/04/virtualbox/</link>
      <pubDate>2014-01-04T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/04/virtualbox</guid>
      <content:encoded><![CDATA[<p>我现在的系统是 Linux Mint 16 (Petra,KDE),在开源社区有提供众多的软件,基本上能够满足工作和学习的需要.不过,对于在国内环境下,有些商业软件并不提供 Linux 支持,比如,我现在使用的招行网银U盾,不能在 Linux 下读取,再比如,厦大图书馆提供的远程访问数据库iReader,只能在window操作系统下使用.</p>

<h2 id="linux--windows-">Linux 下安装 Windows 软件</h2>

<p>对于此类的问题,目前有两种解决方法:</p>

<ol>
  <li>在 Linux 系统中安装 wine,从而可以安装大部分的软件,如QQ等.
    <ul>
      <li>优点:占用的CPU资源少,不影响系统的运行速度</li>
      <li>缺点:设置麻烦,尤其是中文的设置基本是要人命的.典型的就是ireader不能运行.而且还需要相应的安装在 Linux 下的配套软件.</li>
    </ul>
  </li>
  <li>另外一种就是我要介绍的方法:在 Linux 下使用虚拟机安装 Windows 操作系统,在其上面运行软件.
    <ul>
      <li>优点:一劳永逸,简单方便</li>
      <li>缺点:由于虚拟机需要固定的分配内存和硬盘空间,会大大的降低系统的运行速度.</li>
    </ul>
  </li>
</ol>

<p>不过,就目前的笔记本硬件配置来看,一般的内存是4G的,处理器在i3以上,硬盘在500G.在 Linux 下利用虚拟机安装 Windows 系统基本上不会有太大的影响.就本人目前的使用情况来看,效果还是可以接受的.</p>

<p>下面就简单介绍一下我的安装经验.</p>

<h2 id="virtualbox">安装 Virtualbox</h2>

<p>首先是从网站下载 <a href="https://www.virtualbox.org/wiki/Downloads">Virtualbox</a>,这个是 deb 格式的,可以直接点击安装即可.需要 \root 权限.输入密码即可.</p>

<p>然后在终端输入 virtualbox 打开.</p>

<ol>
  <li>点击”新建”一个虚拟机,设置虚拟机名称,并选择相应的操作系统.这个其实意义不大,主要 virtualbox 会根据相应的操作系统分配默认的内存和硬盘空间.
<img src="/assets/virtualbox/vb01.png" alt="vb01" />
<img src="/assets/virtualbox/vb02.png" alt="vb02" />
<img src="/assets/virtualbox/vb03.png" alt="vb03" /></li>
  <li>也就是上一步骤的延续,设定内存大小.建议给主机留多一些内存以加快主机的运行速度.
<img src="/files/virtualbox/vb04.png" alt="vb04" /></li>
  <li>点击”创建”开始建立一个虚拟机.
<img src="/files/virtualbox/vb05.png" alt="vb05" /></li>
  <li>如果不知道虚拟硬盘的文件类型,那就选择默认的”VDI”,点击”下一步”继续.
<img src="/files/virtualbox/vb06.png" alt="vb06" /></li>
  <li>分配虚拟机的硬盘大小,有两种选择
<img src="/files/virtualbox/vb07.png" alt="vb07" />
    <ul>
      <li>动态分配,默认选择,前期不怎么占用硬盘,后面会随着需要而增加.比较适用于硬盘存储比较小的计算机.</li>
      <li>固定大小,这个会占用主机硬盘空间.</li>
    </ul>
  </li>
  <li>选择需要将虚拟机建立在那个文件夹下面.视个人情况而定.我一般是建立在 /home
<img src="/files/virtualbox/vb08.png" alt="vb08" /></li>
  <li>该页面显示已经成功的建立起来一个虚拟机,在上面有对应的配置.这个可以通过设置来更改.
<img src="/files/virtualbox/vb09.png" alt="vb09" /></li>
  <li>为了在虚拟机上面安装 Windows 系统,需要点击”设置”,找到”存储”里面的”分配光驱”,然后选择移动硬盘上的 Windows 7 iso.
<img src="/files/virtualbox/vb10.png" alt="vb010" /></li>
  <li>设置完成后的页面.点击”启动”开始安装系统.
<img src="/files/virtualbox/vb16.png" alt="vb016" /></li>
  <li>普通的 Windows 7 安装过程.
<img src="/files/virtualbox/vb11.png" alt="vb011" /></li>
  <li>成功安装系统,开始启动.
<img src="/files/virtualbox/vb12.png" alt="vb012" />
<img src="/files/virtualbox/vb13.png" alt="vb013" /></li>
  <li>在虚拟机上面的 Win 7 找到 Cd 光驱,点击打开安装扩展应用,期间会重启一次.进入之后可以看到整个 Win 7 的完整系统.
<img src="/files/virtualbox/vb14.png" alt="vb14" /></li>
  <li>设置”共享文件夹”,以实现在主机和虚拟机之间的文件传输.
<img src="/files/virtualbox/vb15.png" alt="vb15" /></li>
</ol>

<h2 id="virtualbox--usb">Virtualbox 识别 USB</h2>

<p>为了能够在主机与虚拟机之间相互使用USB,还需有做如下的设置.</p>

<blockquote>
  <ul>
    <li>由于 virtualbox 默认的是不打开主机的USB插件的.为了实现在虚拟机上读取USB,我们需要安装一个拓展包,<a href="https://www.virtualbox.org/wiki/Downloads">Extention pack</a>.下载完成后点击安装即可.然后重启 virtualbox.   <br /></li>
    <li>同时,为了使 virtualbox 能够识别 USB,还需要将当前用户添加到组里.在终端输入以下命令并重启主机:   <br />
  sudo addgroup wiliam vboxusers  <br /></li>
    <li>接着做一下设置:    <br />
      <ul>
        <li>打开virtualbox,但事先不启动虚拟机.找到”设置”中的”USB设备”,点击右边的”+”以添加USB  <br /></li>
        <li>重启主机,启动虚拟机后就可以通过右下角的USB符号添加.如果不用的话,也可以点击推出.</li>
      </ul>
    </li>
  </ul>
</blockquote>

]]></content:encoded>
    </item>
    
    <item>
      <title>Github 的一些设置技巧</title>
      <link>http://williamlfang.github.com/cn/2014/01/03/github-jekyll/</link>
      <pubDate>2014-01-03T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/03/github-jekyll</guid>
      <content:encoded><![CDATA[<h2 id="gitgithub">Git与Github</h2>

<p>Git是一个分散化的版本管理系统(DVCS),最早是用于处理Linux的远程协作编程,后来开始在编程社区逐渐受到关注,在程序猿们广泛流传.而Github就相当于给Git安装了一个在线的存储系统,用于远程协同,相当于码农们的Facebook.</p>

<h2 id="jekyll">Jekyll</h2>

<blockquote>
  <p>Transform your plain text into static websites and blogs.</p>
</blockquote>

<h2 id="github--jekyll-">使用 Github 和 Jekyll 发表博客</h2>

<p>以下是在 Linux 系统下的 bash 命令语句:</p>

<h3 id="section">复制库到本地磁盘</h3>

<p>从 github 将项目 (project) 复制 (fork) 到本地磁盘中,基本格式是:</p>

<pre><code>git clone git@github.com:USERNAME/USERNAME.github.com.git TARGETED_FILE

git clone git@github.com:USERNAME/Project_Name.git TARGETED_FILE
</code></pre>

<p>其中,TARGETED_FILE 通常是以 USERNAME.github.com.git 作为存放目录.</p>

<ul>
  <li>
    <p>/home/william/williamlfang.github.com. </p>

    <p>git clone git@github.com:williamlfang/williamlfang.github.com.git williamlfang.github.com</p>
  </li>
  <li>
    <p>/home/william/cn</p>

    <p>git clone git@github.com:williamlfang/cn.git cn</p>
  </li>
  <li>
    <p>/home/william/en</p>

    <p>git clone git@github.com:williamlfang/en.git en</p>
  </li>
</ul>

<h3 id="section-1">更改项目文件</h3>

<p>对于修改的文件,如果想要将其上传到 Github 空间存储,需要经过如下几个步骤</p>

<h4 id="williamlfanggithubcom">williamlfang.github.com</h4>

<pre><code>cd /home/william/williamlfang.github.com        # 指定路径
git add . -A           # 上传全部文件 -A
git commit -m ""       #  加上注解说明有助于日后维护:-m

git remote rm origin   # 删除历史保存
git remote add origin git@github.com:williamlfang/williamlfang.github.com.git
git push origin master

jekyll --server        # 在本地文件预览效果, 可打开: 127.0.0.1:4000
</code></pre>

<h4 id="cn">cn</h4>

<pre><code>cd /home/william/cn
git add . -A
git commit -m ""

git remote rm origin
git remote add origin git@github.com:williamlfang/cn.git
git push origin gh-pages

jekyll --server
</code></pre>

<h4 id="en">en</h4>

<pre><code>cd /home/william/en
git add . -A
git commit -m ""

git remote rm origin
git remote add origin git@github.com:williamlfang/en.git
git push origin gh-pages

jekyll --server
</code></pre>

<h2 id="faq">FAQ</h2>

<h3 id="tcpserver-error-address-already-in-use">TCPServer Error: Address already in use</h3>

<p>Solution:</p>

<ol>
  <li>
    <p>在终端输入</p>

    <p>lsof -wni tcp:4000</p>
  </li>
  <li>
    <p>关闭 PID </p>

    <p>kill -9 PID</p>
  </li>
  <li>
    <p>重新生成</p>

    <p>jekyll –server</p>
  </li>
</ol>

<h3 id="ssh-">SSH 错误</h3>

<p><em>引用</em>:<a href="http://blog.csdn.net/keyboardota/article/details/7603630">原文连接</a></p>

<blockquote>
  <p>问题:在新的电脑系统中,首次生成SSH, 系统会报下面的错误：<br />
Permission denied (publickey). <br />
fatal:The remote end hung up unexpectedly <br /></p>
</blockquote>

<blockquote>
  <p>Solution:这时需要在本地创建SSH key，然后将生成的SSH key文件内容添加到github帐号上去。</p>
</blockquote>

<p>创建SSH key的方法很简单，执行如下命令就可以：
- ssh-keygen
- 然后系统提示输入文件保存位置等信息，连续敲三次回车即可，生成的SSH key文件保存在中～/.ssh/id_rsa.pub</p>

<p>然后用文本编辑工具打开该文件，我用的是gedit,所以命令是：
gedit ~/.ssh/id_rsa.pub</p>

<p>接着拷贝.ssh/id_rsa.pub（或者是github.pub）文件内的所以内容，将它粘帖到github帐号管理中的添加SSH key界面中。</p>

<p>打开github帐号管理中的添加SSH key界面的步骤如下：</p>

<ol>
  <li>登录github</li>
  <li>点击右上方的Accounting settings图标</li>
  <li>选择 SSH key</li>
  <li>点击 Add SSH key</li>
  <li>在出现的界面中填写SSH key的名称，填一个你自己喜欢的名称即可，然后将上面拷贝的~/.ssh/id_rsa.pub文件内容粘帖到key一栏，在点击“add key”按钮就可以了。</li>
</ol>

<p>添加过程github会提示你输入一次你的github密码</p>

<p>添加完成后再次执行git clone就可以成功克隆github上的代码库了。</p>

<h3 id="rdiscount-">rdiscount 安装错误</h3>

<blockquote>
  <p>问题:在使用’jekyll –server’出现如下错误    <br />
  ? [suod] gem install rdiscount    <br />
  而如果真的这么干,却出现另外的错误提示   <br />
ERROR: Error installing rdiscount:    <br />
    ERROR: Failed to build gem native extension.</p>
</blockquote>

<blockquote>
  <p>Solution:   <br />
   - 先安装 ruby1.9.1-dev,    <br />
    sudo apt-get install ruby1.9.1-dev     <br />
   - 再安装 rdiscount    <br />
    gem install rdiscount</p>
</blockquote>

]]></content:encoded>
    </item>
    
  </channel>
</rss>
