<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>William Fang</title>
    <atom:link href="http://williamlfang.github.com/cn/feed/" rel="self" type="application/rss+xml" />
    <link>http://williamlfang.github.com</link>
    <lastBuildDate>2014-01-24T03:02:24+08:00</lastBuildDate>
    <webMaster>william.lian.fang@gmail.com</webMaster>
    
    <item>
      <title>使用 Rmarkdown 发表博客</title>
      <link>http://williamlfang.github.com/cn/2014/01/24/shi-yong--rmarkdown--fa-biao-bo-ke/</link>
      <pubDate>2014-01-24T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/24/shi-yong--rmarkdown--fa-biao-bo-ke</guid>
      <content:encoded><![CDATA[<ol>
<li>将文件 <code>rmd.sh</code> 与 <code>rmarkdown.r</code> 需要运行 <code>.R</code> 程序的地方，这样我们以后就可以直接运行 <code>rmd.sh</code> 来自动的转化 <code>.Rmd</code> 为 <code>.md</code> 格式。</li>
</ol>


<p> 如果想要具体的设置，我们可以
  - 首先在目录下建立一个 <code>image</code> 文件用于存放图片
  - 定义图片文件的链接，<code>images.url='/cn/_post/images/'</code>，也就是将来直接发布时的图片链接。</p>

<ol>
<li>需要在 <code>YAML</code> 前面写入</li>
<li><code>published: false</code>:也没有发表</li>
<li><code>status:    process</code>：运行 <code>rmd.sh</code> 后会自动改为 <code>published</code>。</li>
</ol>


<p>比如这个 <code>R</code> 代码</p>

<pre><code>x = rnorm(100)
plot(density(x))
</code></pre>

<p><img src="cn/post/images/figure/unnamed-chunk-1.png" alt="plot of chunk unnamed-chunk-1" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>test</title>
      <link>http://williamlfang.github.com/cn/2014/01/22/test/</link>
      <pubDate>2014-01-22T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/22/test</guid>
      <content:encoded><![CDATA[<div class="btn-toolbar">
  <div class="btn-group">
    <a class="btn" href="#"><i class="icon-align-left"></i></a>
    <a class="btn" href="#"><i class="icon-align-center"></i></a>
    <a class="btn" href="#"><i class="icon-align-right"></i></a>
    <a class="btn" href="#"><i class="icon-align-justify"></i></a>
  </div>
</div>

]]></content:encoded>
    </item>
    
    <item>
      <title>岁月不留，心灵的童年永驻</title>
      <link>http://williamlfang.github.com/cn/2014/01/22/sui-yue-bu-liu--xin-ling-de-tong-nian-yong-zhu/</link>
      <pubDate>2014-01-22T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/22/sui-yue-bu-liu--xin-ling-de-tong-nian-yong-zhu</guid>
      <content:encoded><![CDATA[<p>时间是绝对的，是自由的，不会从属于某个团体，社会，时代，个人。有时我睁着眼睛，看岁月流水哗啦啦的，桀骜不羁，独立特行，任由我这个惊讶的看客嗟叹不止。我知道，来日方长，可是逝去的时光犹如压缩的孢囊，远去多少记忆，却也只是一丁点的回味。我们常说回首岁月，可是却从来都回不到过去，留不下的是时间，留下了自己。</p>

<p>以前有阅读的书籍，看过的电影，品尝的美食，游历的风景，突然哪一天就出现在你的眼前，挥之不去。比如，这个故事集：<a href="/cn/assets/files/%E6%9E%97%E6%B5%B7%E9%9F%B3%EF%BC%9A%E5%9F%8E%E5%8D%97%E6%97%A7%E4%BA%8B.pdf">「城南旧事」</a>。</p>

<p>我记得先前在高中之时，便有看过。现在回想彼时的场景，却是模糊，如同久置的照片，泛着黄昏余日的幽暗。今天刚好手头无事，便在网上找到了文章，开始读起来。</p>

<p>正如作者在序言说的，</p>

<blockquote><p>把他们写下来吧，让实际的童年过去，心灵的童年永存下来。</p></blockquote>

<p>这是一个关于旧日童年的回忆录，由以下几篇短文构成，共同讲述了作者儿时在老北京度过的童年时光。</p>

<ul>
<li>惠安馆传奇</li>
<li>我们看海去</li>
<li>兰姨娘</li>
<li>驴打滚儿</li>
<li>爸爸的花儿落了 我也不再是小孩子</li>
</ul>


<p>里面的文章有孩子的天真无邪，她都这个世界即充满好奇，蠢蠢欲动愈要一窥究竟，</p>

<blockquote><p>做大人，常常有人要我做大人</p></blockquote>

<p>可是，当她长大之后，时间走了，人也老了，却回不到当初的童真，</p>

<blockquote><p>虽然，这些人都随着我的长大没有了影子了。是跟着我失去的童年一起失去了吗？</p></blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Advanced R Programming:&quot;Data Structure&quot;</title>
      <link>http://williamlfang.github.com/cn/2014/01/22/shu-ju-jie-gou/</link>
      <pubDate>2014-01-22T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/22/shu-ju-jie-gou</guid>
      <content:encoded><![CDATA[<p>这一章主要介绍了在 <strong>R</strong> 中最基本的元素：数据。前段时间我在网上看到一个帖子（暂时忘记在哪里找到了），强调「data science」的重心不是在前面的那个「data」，而是后面的「science」。这是因为随着互联网的深入发展，我们现在不再是缺乏数据，反而是面临着「big data」造成的「information rich」（信息冗余）的困扰。因此，今后的数据科学应当更进一步的发展新的理论与方法来解决大数据分析。</p>

<p>好了，这个扯远了。不过在 <strong>R</strong> 中，我们最紧要的事情就是：给了一大箩筐的数据，可能是排列完整的，不过大多数情况下是混乱不堪的，要求对这些数据做统计分析与可视化工作。这个基本上是一件既头疼又心烦的苦差事。首先的任务是，先对这些数据做一定格局的处理，得到我们后续需要使用的信息变量。因此，熟练掌握处理数据的基本方法，对未来的分析至关重要。</p>

<h2>概览</h2>

<p>Wickham 用一张表格总结了 <strong>R</strong> 中的数据结构</p>

<blockquote><p>R's base data structures are summarised in the table below, organised by their dimensionality and whether they're homogeneous (all contents must be of the same type) or heterogeneous (the contents can be of different types):</p></blockquote>

<table>
<thead>
<tr>
<th>    </th>
<th> Homogeneous   </th>
<th> Heterogeneous </th>
</tr>
</thead>
<tbody>
<tr>
<td> 1d </td>
<td> Atomic vector </td>
<td> List          </td>
</tr>
<tr>
<td> 2d </td>
<td> Matrix        </td>
<td> Data frame    </td>
</tr>
<tr>
<td> nd </td>
<td> Array         </td>
<td>               </td>
</tr>
</tbody>
</table>


<p>需要解释的是标量（scalar）。什么是标量呢？就是一个个单独的变量，如</p>

<pre><code class="r">x &lt;- 5
y &lt;- "scalar"

x
</code></pre>

<pre><code>## [1] 5
</code></pre>

<pre><code class="r">y
</code></pre>

<pre><code>## [1] "scalar"
</code></pre>

<p><strong>R</strong> 默认地将标量识别为 1*1 的向量（vector），也就是 0-dimensional。</p>

<blockquote><p>这里科普一下有关 <strong>R</strong> 中的面向对象的特征。也就是说， <strong>R</strong> 中所有的元素都可以叫做「对象」（obgect），这不仅仅是基本的数据，如向量、data frame，还包括函数（function）、环境（environment），甚至是符号（symbols）。 <strong>R</strong> 处理完分析后得到的就是一个对象，我们需要哪儿元素，直接提取就可以了。比如，</p></blockquote>

<pre><code class="r">df = data.frame(x = rnorm(100, 0, 1), y = seq(from = 1, to = 100))
result &lt;- lm(y ~ x, data = df)

result
</code></pre>

<pre><code>    ## 
    ## Call:
    ## lm(formula = y ~ x, data = df)
    ## 
    ## Coefficients:
    ## (Intercept)            x  
    ##       50.45        -2.68
</code></pre>

<blockquote><p>得到的结果存储在 <code>result</code> 里，这个就是一个对象，等到我们需要使用其中的「子对象」时，再从中提取即可</p></blockquote>

<pre><code class="r">result$coeff
</code></pre>

<pre><code>## (Intercept)           x 
##      50.448      -2.677
</code></pre>

<p>面向对象的编程能够提供非常灵活的数据处理结果，并且具有较高的程序维护性。这在 <strong>R</strong> 得到了极大的展现。</p>

<h3><code>str()</code>：查看数据结构</h3>

<p>查看数据类型可以使用命令 <code>str()</code></p>

<pre><code class="r">str(df)
</code></pre>

<pre><code>## 'data.frame':    100 obs. of  2 variables:
##  $ x: num  0.3458 -0.0375 0.1819 -0.0819 0.1932 ...
##  $ y: int  1 2 3 4 5 6 7 8 9 10 ...
</code></pre>

<h2>向量</h2>

<p>如上所述， <strong>R</strong> 中主要的一维数据类型包括 <code>atomic vector</code>（基础向量） 和 <code>list</code>（列表），前者要求罗列其中的数据均是同属性的，比如 <code>logical</code>，<code>interger</code>，<code>double</code>，和 <code>character</code>。而后者 <code>list</code> 则可以是多种数据类型的混合。</p>

<h3>基础向量</h3>

<p>基础向量是组成 <strong>R</strong> 编程语言的基石，可以由此构成其他类型的数据结构。怎么去理解  <strong>R</strong> 中的向量呢？</p>

<h4>数据的向量化</h4>

<p>其实，这个可以看作是一个研究变量的序列观测值。比如</p>

<pre><code class="r">x &lt;- c(35.6, 36.1, 35.8, 37, 36.5, 37.2, 35.8)
str(x)
</code></pre>

<pre><code>##  num [1:7] 35.6 36.1 35.8 37 36.5 37.2 35.8
</code></pre>

<pre><code class="r">is.vector(x)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>这个就是一个向量，可以视为一天中在七个不同时间段的气温观测。因此，我们可以利用这个向量来产生矩阵，从而实现多元变量在不同时间序列上的观测值。其实，这种数据的向量化不仅提供了对数据的直观理解，而且还能提高 <strong>R</strong> 的运算速度，尽量避免使用循环，优化程序。这点我们在日后会继续讨论。</p>

<h4>生成向量的方法</h4>

<p>用于生成向量的命令主要有：</p>

<ul>
<li><p><code>c()</code>:即「canbinate」的意思，用于生成一个向量，并且可用于嵌套</p>

<pre><code class="``r">  a &lt;- c(1, 2, 4, 6, 8)
  b &lt;- c(1, c(2, c(4, 6.8)))  # 套嵌使用
  a == b
</code></pre>

<pre><code class="``">  ## Warning: longer object length is not a multiple of shorter object length
</code></pre>

<pre><code class="``">  ## [1]  TRUE  TRUE  TRUE FALSE FALSE
</code></pre>

<pre><code class="``r">
  s &lt;- c(1:10)  # 一个序列。相当于 seq(from = 1, to = 10, by= 1)
  s
</code></pre>

<pre><code class="``">  ##  [1]  1  2  3  4  5  6  7  8  9 10
</code></pre>

<pre><code class="``r">
  int &lt;- c(1L, 6L, 8L)  # 产生integer类

  log &lt;- c(T, F, F, T, T)  # logical

  chr &lt;- c("these", "are", "some", "character")
</code></pre></li>
<li><p><code>seq()</code>:即「sequence」的意思，主要用于产生一个带有规律的序列</p>

<pre><code class="``r">  f &lt;- seq(1:10)  # 默认的increament是1,相当于 c(1:10)
  f
</code></pre>

<pre><code class="``">  ##  [1]  1  2  3  4  5  6  7  8  9 10
</code></pre>

<pre><code class="``r">
  g &lt;- seq(from = 1, to = 10, by = 0.5)

  g
</code></pre>

<pre><code class="``">  ##  [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5
  ## [15]  8.0  8.5  9.0  9.5 10.0
</code></pre></li>
<li><p><code>rep()</code>:即[replecate],重复某个数或者某个「序列」，可用于产生较为复杂的数据。</p>

<pre><code class="``r">  h &lt;- rep(5, 10)  # 单个数字的重复
  h
</code></pre>

<pre><code class="``">  ##  [1] 5 5 5 5 5 5 5 5 5 5
</code></pre>

<pre><code class="``r">
  j &lt;- rep(c(1:3), 3)  # 重复一个序列 c(1:3)
  j
</code></pre>

<pre><code class="``">  ## [1] 1 2 3 1 2 3 1 2 3
</code></pre></li>
<li><p><code>rnorm()</code>:产生随机数，还有其他的分布</p>

<pre><code class="``r">  k &lt;- rnorm(100)  #default：rnorm(no, mean = 0, sd = 1)

  l &lt;- rnorm(100, mean = 2, sd = 5)
  plot(density(l))
</code></pre>

<p>  <img src="figure/unnamed-chunk-9.png" alt="plot of chunk unnamed-chunk-9" /></p></li>
</ul>


<h4>类型与长度</h4>

<p><code>typeof()</code> 用于查看数据类型，而 <code>length()</code> 则用于查看向量长度：如果是一维数据，则给出长度；如果是矩阵或者 <code>data.frame</code>，则给出 <code>nrow</code> 与 <code>ncol</code> 的合计。</p>

<pre><code class="r">x &lt;- rnorm(100)
typeof(x)
</code></pre>

<pre><code>## [1] "double"
</code></pre>

<pre><code class="r">length(x)
</code></pre>

<pre><code>## [1] 100
</code></pre>

<pre><code class="r">
y &lt;- c("first", "second", "third")
typeof(y)
</code></pre>

<pre><code>## [1] "character"
</code></pre>

<pre><code class="r">length(y)
</code></pre>

<pre><code>## [1] 3
</code></pre>

<pre><code class="r">
z &lt;- c(T, T, F)
typeof(z)
</code></pre>

<pre><code>## [1] "logical"
</code></pre>

<pre><code class="r">length(z)
</code></pre>

<pre><code>## [1] 3
</code></pre>

<pre><code class="r">
w &lt;- seq(from = 1, to = 10, by = 1)
typeof(w)
</code></pre>

<pre><code>## [1] "double"
</code></pre>

<pre><code class="r">length(w)
</code></pre>

<pre><code>## [1] 10
</code></pre>

<pre><code class="r">
mat &lt;- matrix(rnorm(20), nrow = 4, ncol = 5)
typeof(mat)
</code></pre>

<pre><code>## [1] "double"
</code></pre>

<pre><code class="r">length(mat)
</code></pre>

<pre><code>## [1] 20
</code></pre>

<h3><code>list</code>:列表</h3>

<p>我们已经知道，<code>vector</code>是用于同种类型属性的数据，而<code>list</code>则适用于不同类型的数据，可以说是各种数据的一个「大火锅」。我们使用<code>list()</code>来生成数据，不是之前介绍的<code>c()</code>。</p>

<pre><code class="r">u &lt;- list(1:3, "cha", T, F, c(1, 4, 7), rep(1, 3), seq(1:5))

u
</code></pre>

<pre><code>## [[1]]
## [1] 1 2 3
## 
## [[2]]
## [1] "cha"
## 
## [[3]]
## [1] TRUE
## 
## [[4]]
## [1] FALSE
## 
## [[5]]
## [1] 1 4 7
## 
## [[6]]
## [1] 1 1 1
## 
## [[7]]
## [1] 1 2 3 4 5
</code></pre>

<pre><code class="r">str(u)
</code></pre>

<pre><code>## List of 7
##  $ : int [1:3] 1 2 3
##  $ : chr "cha"
##  $ : logi TRUE
##  $ : logi FALSE
##  $ : num [1:3] 1 4 7
##  $ : num [1:3] 1 1 1
##  $ : int [1:5] 1 2 3 4 5
</code></pre>

<pre><code class="r">typeof(u)
</code></pre>

<pre><code>## [1] "list"
</code></pre>

<p>当然，<code>list</code>也可以跟<code>c()</code>一样实现套嵌(Wickham称之为[recursive])</p>

<pre><code class="r">v &lt;- list(list(2, 4, T, "nope", seq(4:8)), rep(3:4, 2), list(T, F, "yes"))
v
</code></pre>

<pre><code>## [[1]]
## [[1]][[1]]
## [1] 2
## 
## [[1]][[2]]
## [1] 4
## 
## [[1]][[3]]
## [1] TRUE
## 
## [[1]][[4]]
## [1] "nope"
## 
## [[1]][[5]]
## [1] 1 2 3 4 5
## 
## 
## [[2]]
## [1] 3 4 3 4
## 
## [[3]]
## [[3]][[1]]
## [1] TRUE
## 
## [[3]][[2]]
## [1] FALSE
## 
## [[3]][[3]]
## [1] "yes"
</code></pre>

<pre><code class="r">
str(v)
</code></pre>

<pre><code>## List of 3
##  $ :List of 5
##   ..$ : num 2
##   ..$ : num 4
##   ..$ : logi TRUE
##   ..$ : chr "nope"
##   ..$ : int [1:5] 1 2 3 4 5
##  $ : int [1:4] 3 4 3 4
##  $ :List of 3
##   ..$ : logi TRUE
##   ..$ : logi FALSE
##   ..$ : chr "yes"
</code></pre>

<pre><code class="r">typeof(v)
</code></pre>

<pre><code>## [1] "list"
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>Data Structure</title>
      <link>http://williamlfang.github.com/cn/2014/01/22/shu-ju-jie/</link>
      <pubDate>2014-01-22T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/22/shu-ju-jie</guid>
      <content:encoded><![CDATA[<p>这一章主要介绍了在 <strong>R</strong> 中最基本的元素：数据。前段时间我在网上看到一个帖子（暂时忘记在哪里找到了），强调「data science」的重心不是在前面的那个「data」，而是后面的「science」。这是因为随着互联网的深入发展，我们现在不再是缺乏数据，反而是面临着「big data」造成的「information rich」（信息冗余）的困扰。因此，今后的数据科学应当更进一步的发展新的理论与方法来解决大数据分析。</p>

<p>好了，这个扯远了。不过在 <strong>R</strong> 中，我们最紧要的事情就是：给了一大箩筐的数据，可能是排列完整的，不过大多数情况下是混乱不堪的，要求对这些数据做统计分析与可视化工作。这个基本上是一件既头疼又心烦的苦差事。首先的任务是，先对这些数据做一定格局的处理，得到我们后续需要使用的信息变量。因此，熟练掌握处理数据的基本方法，对未来的分析至关重要。</p>

<h2>概览</h2>

<p>Wickham 用一张表格总结了 <strong>R</strong> 中的数据结构</p>

<blockquote><p>R's base data structures are summarised in the table below, organised by their dimensionality and whether they're homogeneous (all contents must be of the same type) or heterogeneous (the contents can be of different types):</p>

<table>
<thead>
<tr>
<th>    </th>
<th> Homogeneous   </th>
<th> Heterogeneous </th>
</tr>
</thead>
<tbody>
<tr>
<td> 1d </td>
<td> Atomic vector </td>
<td> List          </td>
</tr>
<tr>
<td> 2d </td>
<td> Matrix        </td>
<td> Data frame    </td>
</tr>
<tr>
<td> nd </td>
<td> Array         </td>
<td>               </td>
</tr>
</tbody>
</table>
</blockquote>

<p>需要解释的是标量（scalar）。什么是标量呢？就是一个个单独的变量，如</p>

<pre><code>x &lt;- 5
y &lt;- "scalar"

x

## [1] 5

y

## [1] "scalar"
</code></pre>

<p><strong>R</strong> 默认地将标量识别为 1*1 的向量（vector），也就是 0-dimensional。</p>

<blockquote><p>这里科普一下有关 <strong>R</strong> 中的面向对象的特征。也就是说， <strong>R</strong> 中所有的元素都可以叫做「对象」（obgect），这不仅仅是基本的数据，如向量、data frame，还包括函数（function）、环境（environment），甚至是符号（symbols）。 <strong>R</strong> 处理完分析后得到的就是一个对象，我们需要哪儿元素，直接提取就可以了。比如，</p></blockquote>

<pre><code>    df = data.frame(x = rnorm(100, 0, 1), y = seq(from = 1, to = 100))
    result &lt;- lm(y ~ x, data = df)

    result

    ## 
    ## Call:
    ## lm(formula = y ~ x, data = df)
    ## 
    ## Coefficients:
    ## (Intercept)            x  
    ##       50.55        -2.08
</code></pre>

<blockquote><p>得到的结果存储在 <code>result</code> 里，这个就是一个对象，等到我们需要使用其中的「子对象」时，再从中提取即可</p></blockquote>

<pre><code>    result$coeff

    ## (Intercept)           x 
    ##      50.547      -2.083
</code></pre>

<p>面向对象的编程能够提供非常灵活的数据处理结果，并且具有较高的程序维护性。这在 <strong>R</strong> 得到了极大的展现。</p>

<h3><code>str()</code>：查看数据结构</h3>

<p>查看数据类型可以使用命令 <code>str()</code></p>

<pre><code>str(df)

## 'data.frame':    100 obs. of  2 variables:
##  $ x: num  0.131 -0.154 -0.971 2.174 -0.979 ...
##  $ y: int  1 2 3 4 5 6 7 8 9 10 ...
</code></pre>

<h2>向量</h2>

<p>如上所述， <strong>R</strong> 中主要的一维数据类型包括 <code>atomic vector</code>（基础向量） 和 <code>list</code>（列表），前者要求罗列其中的数据均是同属性的，比如 <code>logical</code>，<code>interger</code>，<code>double</code>，和 <code>character</code>。而后者 <code>list</code> 则可以是多种数据类型的混合。</p>

<h3>基础向量</h3>

<p>基础向量是组成 <strong>R</strong> 编程语言的基石，可以由此构成其他类型的数据结构。怎么去理解  <strong>R</strong> 中的向量呢？</p>

<h4>数据的向量化</h4>

<p>其实，这个可以看作是一个研究变量的序列观测值。比如</p>

<pre><code>x &lt;- c(35.6, 36.1, 35.8, 37, 36.5, 37.2, 35.8)
str(x)

##  num [1:7] 35.6 36.1 35.8 37 36.5 37.2 35.8

is.vector(x)

## [1] TRUE
</code></pre>

<p>这个就是一个向量，可以视为一天中在七个不同时间段的气温观测。因此，我们可以利用这个向量来产生矩阵，从而实现多元变量在不同时间序列上的观测值。其实，这种数据的向量化不仅提供了对数据的直观理解，而且还能提高 <strong>R</strong> 的运算速度，尽量避免使用循环，优化程序。这点我们在日后会继续讨论。</p>

<h4>生成向量的方法</h4>

<p>用于生成向量的命令主要有：</p>

<ul>
<li><p><code>creat()</code>:即「canbinate」的意思，用于生成一个向量，并且可用于嵌套</p>

<pre><code>  a &lt;- c(1, 2, 4, 6, 8)
  b &lt;- c(1, c(2, c(4, 6.8)))  # 套嵌使用
  a == b

  ## Warning: longer object length is not a multiple of shorter object length

  ## [1]  TRUE  TRUE  TRUE FALSE FALSE


  s &lt;- c(1:10)  # 一个序列。相当于 seq(from = 1, to = 10, by= 1)
  s

  ##  [1]  1  2  3  4  5  6  7  8  9 10


  int &lt;- c(1L, 6L, 8L)  # 产生integer类

  log &lt;- c(T, F, F, T, T)  # logical

  chr &lt;- c("these", "are", "some", "character")
</code></pre></li>
<li><p><code>seq()</code>:即「sequence」的意思，主要用于产生一个带有规律的序列</p>

<pre><code>  f &lt;- seq(1:10)  # 默认的increament是1,相当于 c(1:10)
  f

  ##  [1]  1  2  3  4  5  6  7  8  9 10


  g &lt;- seq(from = 1, to = 10, by = 0.5)

  g

  ##  [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5
  ## [15]  8.0  8.5  9.0  9.5 10.0
</code></pre></li>
<li><p><code>rep()</code>:即[replecate],重复某个数或者某个「序列」，可用于产生较为复杂的数据。</p>

<pre><code>  h &lt;- rep(5, 10)  # 单个数字的重复
  h

  ##  [1] 5 5 5 5 5 5 5 5 5 5


  j &lt;- rep(c(1:3), 3)  # 重复一个序列 c(1:3)
  j

  ## [1] 1 2 3 1 2 3 1 2 3
</code></pre></li>
<li><p><code>rnorm()</code>:产生随机数，还有其他的分布</p>

<pre><code>  k &lt;- rnorm(100)  #default：rnorm(no, mean = 0, sd = 1)

  l &lt;- rnorm(100, mean = 2, sd = 5)
  plot(density(l))
</code></pre>

<p>  <img src="/cn/images/figure/unnamed-chunk-9.png" alt="plot of chunk unnamed-chunk-9" /></p></li>
</ul>


<h4>类型与长度</h4>

<p><code>typeof()</code> 用于查看数据类型，而 <code>length()</code> 则用于查看向量长度：如果是一维数据，则给出长度；如果是矩阵或者 <code>data.frame</code>，则给出 <code>nrow</code> 与 <code>ncol</code> 的合计。</p>

<pre><code>x &lt;- rnorm(100)
typeof(x)

## [1] "double"

length(x)

## [1] 100


y &lt;- c("first", "second", "third")
typeof(y)

## [1] "character"

length(y)

## [1] 3


z &lt;- c(T, T, F)
typeof(z)

## [1] "logical"

length(z)

## [1] 3


w &lt;- seq(from = 1, to = 10, by = 1)
typeof(w)

## [1] "double"

length(w)

## [1] 10


mat &lt;- matrix(rnorm(20), nrow = 4, ncol = 5)
typeof(mat)

## [1] "double"

length(mat)

## [1] 20
</code></pre>

<h3><code>list</code>:列表</h3>

<p>我们已经知道，<code>vector</code>是用于同种类型属性的数据，而<code>list</code>则适用于不同类型的数据，可以说是各种数据的一个「大火锅」。我们使用<code>list()</code>来生成数据，不是之前介绍的<code>c()</code>。</p>

<pre><code>u &lt;- list(1:3, "cha", T, F, c(1, 4, 7), rep(1, 3), seq(1:5))

u

## [[1]]
## [1] 1 2 3
## 
## [[2]]
## [1] "cha"
## 
## [[3]]
## [1] TRUE
## 
## [[4]]
## [1] FALSE
## 
## [[5]]
## [1] 1 4 7
## 
## [[6]]
## [1] 1 1 1
## 
## [[7]]
## [1] 1 2 3 4 5

str(u)

## List of 7
##  $ : int [1:3] 1 2 3
##  $ : chr "cha"
##  $ : logi TRUE
##  $ : logi FALSE
##  $ : num [1:3] 1 4 7
##  $ : num [1:3] 1 1 1
##  $ : int [1:5] 1 2 3 4 5

typeof(u)

## [1] "list"
</code></pre>

<p>当然，<code>list</code>也可以跟<code>c()</code>一样实现套嵌 (Wickham称之为[recursive])</p>

<pre><code>v &lt;- list(list(2, 4, T, "nope", seq(4:8)), rep(3:4, 2), list(T, F, "yes"))
v

## [[1]]
## [[1]][[1]]
## [1] 2
## 
## [[1]][[2]]
## [1] 4
## 
## [[1]][[3]]
## [1] TRUE
## 
## [[1]][[4]]
## [1] "nope"
## 
## [[1]][[5]]
## [1] 1 2 3 4 5
## 
## 
## [[2]]
## [1] 3 4 3 4
## 
## [[3]]
## [[3]][[1]]
## [1] TRUE
## 
## [[3]][[2]]
## [1] FALSE
## 
## [[3]][[3]]
## [1] "yes"


str(v)

## List of 3
##  $ :List of 5
##   ..$ : num 2
##   ..$ : num 4
##   ..$ : logi TRUE
##   ..$ : chr "nope"
##   ..$ : int [1:5] 1 2 3 4 5
##  $ : int [1:4] 3 4 3 4
##  $ :List of 3
##   ..$ : logi TRUE
##   ..$ : logi FALSE
##   ..$ : chr "yes"

typeof(v)

## [1] "list"
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>Advanced R Programming</title>
      <link>http://williamlfang.github.com/cn/2014/01/20/r-note/</link>
      <pubDate>2014-01-20T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/20/r-note</guid>
      <content:encoded><![CDATA[<p>这个文档记录了我在学习 <a href="http://had.co.nz/">Hadley Wickham</a> 即将出版的新书，<a href="http://adv-r.had.co.nz/">Advanced R Programming</a> 时的一些笔记与总结，以便将来复习查阅。该书博大精深，结构严谨，涵盖面广泛，涉及几乎目前有关「R」的所有问题。从最基础的数据结构开始讲起，然后逐步渐进到如何编写针对问题的 <code>function</code>，再进阶到如何开发能够发布以供他人使用的 <code>package</code>。Wickham 本人就是在「R Community」团体中的传奇人物，开发了许多为人称道的宏包，如 <code>ggplot2</code>等。而本书真是作者在总结了近十年的 「R」软件开发后编写的一本巨著。仔细深入阅读此书必将受益匪浅，极大的提升我们使用与开发「R」的各项技能，真正从最底层去认识「R」这个当今最强大的数据处理、统计分析与图形可视化编程语言。</p>

<p>正如他自己所说的：</p>

<blockquote><p>I have been programming in R for over 10 years, spending a lot of time trying to figure out how the language works. Not everyone has the luxury of spending years to understand a programming language, so this book is my attempt to help you to become an effective R programmer as quickly as possible. By reading this book, you will avoid the many mistakes that I made and the many dead ends that I got stuck in, and quickly navigate your way to useful tools and techniques. Although R has its frustrating quirks, I truly believe that at its heart lies an elegant and beautiful language, well tailored for data analysis and statistics. In this book, I'll do my best to reveal that language to you, helping you to understand powerful idioms that allow you to attack many types of problems.</p></blockquote>

<h2>Why 「R」</h2>

<p>对于这个问题的回答，最简短的回答是</p>

<blockquote><p>多学一门编程语言总不会死吧？！！！</p></blockquote>

<p>确实，在当今这个互联网与信息时代，我们的生活与工作与电脑紧密相连、形影不离，如果要想了解这个时代、这个世界，我们首先必须先了解那些控制与主宰了我们生活节奏的「电脑们」是如何「生活」的。进一步说，即那些操控了「电脑们」的<strong>「程序」</strong>是如何运行的。而所谓的「程序」，终归到底，是「程序语言」（Programming language）。前几年流行的一本「Hakers and Painters」就在序言开宗明义地说：</p>

<blockquote><p>Everything around us is turning into computers. Your typewriter is gone, replaced by a computer. Your phone has turned into a computer. So has your camera. Soon your Tv will. Your car was not only designed on computers, but has more processing power in it than a room-sized mainframe did in 1970. Letters, encyclopedias, newspapers, and even your local store are being replaced by the Internet.</p></blockquote>

<p>因此，我们要想了解世界，就必须先懂得这个世界在说什么（编程）「语言」。所谓「技多不压身」，多学习一门「编程语言」也促使我们从另外一个角度看世界，多一种批判的眼光，多一层思维的觉悟。何乐而不为？</p>

<p>当然，如果你是首次听说/接触「R」，对这个编程语言一点冲动的想法都没有，那我就需要找各种<em>理由</em>来劝说你「是时候该学习『R』了」，哪怕是对阅读统计报告的需要。</p>

<p><em>注意</em>：真是下面的几条<em>Reasons</em>把我拉入了「R」介个广大的「神教」中，有幸或不幸，我也希望你来加入！</p>

<ul>
<li><p>「R」是处理统计数据与图形可视化的「神器」，能够高效的完成各种数据分析，生成信息充实而页面精美的图形。一方面，我们可是直接使用现今已有的软件包（通过<code>install.packages("")</code>)，涵盖了从基本的统计分析方法，如计算均值，方差分析，到时下最前沿的统计方法，可用于处理有关统计建模、机器学习、大数据管理等问题;另一方面，如果发现现有的软件包不能满足或者不适合手头问题的解决，那么我们还可以自己动手开发。这个特性赋予了「R」强大的处理数据的能力。</p></li>
<li><p>「R」是一款<strong>自由的开源软件体</strong>。这意味着你有权限去获取、使用、修改甚至是发行任何版本的「R」程序。这一点对于使用<code>Windows</code>的用户可能不会意识到有多重要，因为在国内的环境中，我们从来都没有关心过一款软件的「版权」问题，心想着反正上网有大量的破解软件可供下载使用。可是对于一个合格的哪怕只是刚入门的「Geek」来说，我已经不能再忍受破解（=盗版=病毒）软件的荼毒。从网上某处下载的软件，总是神乎其神的在某个地方给你添加插件，修改管理者权限，安装不必要也不想要的软件。然后在某天开机之后，屏幕变黑，系统变坏，情绪变糟。</p>

<p>  后来我开始转移阵地到「Linux」，开始慢慢接触开源项目，才逐渐领会到开源软件带来的自由。比如，我可以从互联网以「正当理由」、「合理方式」获得所需的软件，并能够在尊重原开发者的情况下修改软件，生成「私人定制」，我甚至还可以将其发布到网上供他人使用。涉及到软件的自由是多层次的，其中最基本的一条就是，我可以修改、进一步开发以利解决问题。</p>

<p>  「R」就是这么一个软件，她给你所需，为你所用，助你之力。</p>

<p>   同时，「R」的开源特性也意味着这是一个免费的软件，我们可以以零成本的价格使用。这对于一枚「学生党」，有着「千情万钟」的诱惑（刨去破解软件）。</p></li>
<li><p>分散在世界各地的「R Community」为这个编程语言持续地注入新鲜的生命力，使之长久延续。我们可以到「CRAN」、<a href="https://stat.ethz.ch/mailman/listinfo/r-help">R-help mailing list</a>、<a href="http://stackoverflow.com/questions/tagged/r">StackOverflow</a>寻求帮助，也可以通过当地的「R user group」来咨询方案。不同与其他的编程语言，「R」的开源共享的属性让她得到世界各地用户的偏好，共同开发以保持其活力。我们无需担心哪一天自己辛苦学习与使用的编程语言/软件就撒手不干停止更新服务了。因此，学习「R」几乎是一个「零（违约）风险」的投资。</p></li>
<li><p>可重复（reproducable）研究指得是在现有的数据框架下，我们可以通过复制原来研究成果的代码来验证其准确性。这区别于更加广泛意义上的可复制（replecated）研究，即需要重新收集数据样本来复制结果。可重复研究允许我们在有限的经费预算约束下，极大可能的验证科学研究成果。</p>

<p>  「R」正是开发可重复研究的利器，提供了像<code>knitr</code>这样优秀的软件包，使得统计分析的任何一个过程都可以通过运行代码来检验研究成果。同时，我们还可以在文章正文中「植入」程序代码，直接计算结果（面向对象，object-oriented）、绘制图形（ggplot2）、编制表格（tabular，xtable）。这省去了传统的撰写文章的麻烦与琐碎。比如，原先我们可能是在「LaTex」中写入论述，等到了需要使用图形的地方，需要事先标明<code>\includegraphic{}</code>，然后通过查找对应的图片插入。这期间被各种「烦文缛节」、各种「黑暗技巧」搞得晕头转向、不知何处。最后搞不好还弄错了文字与图形的匹配。而这些统统在<code>knitr</code>中可以自动完成，我们需要的，就是顺着思维的路线一路走下去，该说人话的时候就写人话，该使用机器语言就直接健入代码产生需要的结果或者图形。真可谓</p>

<blockquote><p>「R」与「LaTex」齐飞，思想代码共一体。</p></blockquote></li>
<li><p>此外，「R」还是一个<em>跨平台</em>的软件体，通吃「三界」：</p>

<ul>
<li>Windows系统可以直接点击<code>.exe</code>软件来安装;</li>
<li><p>Linux系统使用命令安装：</p>

<pre><code> sudo apt-get install r-base r-base-dev
</code></pre></li>
<li><p>Mac系统。（抱歉，我没有使用Mac，故此处不敢高声语。）</p></li>
</ul>
</li>
</ul>


<h2>Why <em>Not</em> 「R」</h2>

<p>对于这个问题，我真的不知该如何回答。如果说以上的几点理由还不够具有「杀伤力」，那在下也只能自愧功力不够、道行尚浅、修行有限。</p>

<p>不过还好，大神来帮忙了：</p>

<blockquote><p>Of course, R is not perfect. R's biggest challenge is that most R users are not programmers.</p></blockquote>

<p>他给出的批评无非是「double-edged sword」，所谓凡是有利有弊、一正一邪。各位看官可以到大神的网上去找找不使用「R」的「牵强附会」的理由。在下无需多言，只不过再此累赘一下，也算是个人当初的体会</p>

<ul>
<li>「R」的学习曲线太陡峭、成本太高了。也就是说，对于一个初学者来说，「R」的代码几乎可以说是「摧枯拉朽」、「灭顶之灾」的。原因有二：

<ul>
<li><p>「R」掺杂了其他语言的使用，如<strong>C</strong>，<strong>Python</strong>。这旨在提高「R」的运行速度与计算能力，增强数据分析。不过这对「beginner」却造成了困扰。</p>

<blockquote><p>我的建议是：既来之，则安之。一开始看不懂没关系，先试着挑-「好看」的来，然后再进一步深入学习。等到你真正需要扩展的时候，再去找些资料学习就可以了。</p></blockquote></li>
<li><p>「R」对于编写程序没有过于严格的要求，是真正意义上的「注重结果」的编程语言。这直接造成了「恶劣影响」，导致许多的代码行都不大注重严谨，缺乏统一。看不懂别人的代码那是必须的，有时甚至都看不懂自己以前写的代码了。,,Ծ‸Ծ,,</p>

<blockquote><p>推荐：多看多看多看！没见过猪跑也好歹有吃过猪肉。另外，可以看看一些「guide」，养成良好的编写程序的习惯，比如，大神的<a href="http://adv-r.had.co.nz/Style.html">建议</a>,以及<a href="http://google-styleguide.googlecode.com/svn/trunk/Rguide.xml">Google's R Style Guide</a></p></blockquote></li>
</ul>
</li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>WineQQ2013 可以使用</title>
      <link>http://williamlfang.github.com/cn/2014/01/18/qq-for-linux/</link>
      <pubDate>2014-01-18T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/18/qq-for-linux</guid>
      <content:encoded><![CDATA[<h2>QQ for <code>Linux</code></h2>

<p>想要在Linux操作系统下使用 <code>QQ</code> 真的得费不少劲。我之前尝试通过 <code>WINE</code> 来安装 <code>QQ2013</code>，可是最终以失败结束。</p>

<ul>
<li><p>一方面是由于目前的 <code>WINE</code> 技术还不是很好，对于一些商业软件支持力度不够，也不能完全模拟 <code>Windows</code> 系统来安装 <code>.exe</code> 的软件（如果完全取代了，怎么感觉又回到 <code>Windows</code> 时代了呢.....），期间需要不停的下载相关而不必要的软件，大费人力与（电）脑力，而且终归落得个不能使用/中文乱码的惨淡结局。</p></li>
<li><p>另一方面，<code>Tencent</code> 公司也不会完全放弃 <code>QQ</code> 的商业价值来满足开源爱好者的，他们满眼看到的是商业利益。<code>QQ</code> 本身是一个具有黑暗魔法力量的软件，可以推送广告取得收入，可以不间断的搜索用户资料（先前有 3Q 大战及由此来），还能维护一个庞大的软件生态链。故此，虽然曾经有一段时间的 <code>QQ for Linux</code> 的美好光景，却也一去不复返。</p></li>
</ul>


<p>我们现在想要在 Linux 上使用 <code>QQ</code>，真可谓“斗智斗勇”，方能取得一丁点的成就。</p>

<h2>虚拟机下使用 QQ</h2>

<p>我之前有在一篇关于虚拟机 <a href="http://williamlfang.github.io/cn/2014/01/04/virtualbox/">virtualbox</a> 的文章中谈过可以利用虚拟机来运行 <code>Windows</code> 操作系统，并在其使用 <code>QQ</code> 等软件。可以，这也很不方便，为了使用一个软件大开虚拟机占用大量的内存，实属不值，何况对于一些老机子更是苦命。因此，我决定放弃这个既浪费资源又不讨好的想法，另辟蹊径。</p>

<h2>WineQQ</h2>

<p>目前，由一个叫做 “LongeneTeam” 团队给广大的用户带来了福音。他们号称开发了史上最牛叉的、能够在 Linux 系统运行的 <code>wineQQ</code>。其工作原理是：</p>

<blockquote><p>通过以deb的格式将 QQ 软件、Wine基本配置、有关字体以及一些必要的配件统统打包好，这样用户可以直接点击deb文件来安装、使用 QQ。</p></blockquote>

<p>目前 wineQQ 的最新版本为 <a href="http://www.longene.org/forum/viewtopic.php?t=4700">wine-1.7.9</a>。deb格式的软件可以在<a href="http://pan.baidu.com/s/1hq83fWo">这里</a>或者<a href="http://www.longene.org/download/WineQQ2013SP6-20140102-Longene.deb">这里</a>下载到。之后可以直接双击打开，经由 <code>Software Manager</code> 确认系统密码后即可安装。完成之后在找到 <code>QQ</code> 打开即可。
<img src="/cn/assets/images/QQ/qq.png" alt="wineqq2013" /></p>

<h2>问题之门及解决之道</h2>

<p>以下汇集了我在使用 wineQQ2013 过程中遇到的一些问题，以及相应的解决方法。欢迎补充。</p>

<h3>64位操作系统不能运行</h3>

<p>这个问题主要是由于原先只是在32位系统运行的 <code>wineQQ</code> 需要安装配件。如下：</p>

<div class="highlight"><pre><code class="bash"><span class="lineno">1</span> sudo apt-get install libc6-i386 
<span class="lineno">2</span> sudo apt-get install ia32-libs
</code></pre>
</div>



]]></content:encoded>
    </item>
    
    <item>
      <title>Images</title>
      <link>http://williamlfang.github.com/cn/2014/01/18/img/</link>
      <pubDate>2014-01-18T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/18/img</guid>
      <content:encoded><![CDATA[<p>This thread will show you how to add a new images in Markdown through <code>relative path</code>.</p>

<ol>
<li><p>Make sure that you have already set the <code>url</code> correctly as <code>williamlfang.github.com</code>.</p></li>
<li><p>Now that we wanna to add new images in the website as <code>williamlfang.github.com/cn</code>, which is a <code>gh-pages</code>. Unfortunely, all the <code>url</code> links are directed to the main repo <code>williamlfang.github.com</code> instead of the <code>williamlfang.github.com/cn</code>. This is what the following to be utilized.</p></li>
<li><p>Suppose you have created a relative path containing folder as <code>assets/images/btt.png</code>, all you need to do is to add the additional prelix <code>/cn</code> alongsie the relative file path <code>assets/images/btt.png</code>. See below as as example:</p></li>
</ol>


<div class="highlight"><pre><code class="bash">!<span class="o">[</span>bottom<span class="o">](</span>/cn/assets/images/btt.png<span class="o">)</span>
</code></pre>
</div>


<p>which gives
<img src="/cn/assets/images/btt.png" alt="bottom" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Linux Mint 安装 Pandoc</title>
      <link>http://williamlfang.github.com/cn/2014/01/16/pandoc/</link>
      <pubDate>2014-01-16T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/16/pandoc</guid>
      <content:encoded><![CDATA[<h2>下面介绍在 Linux Mint 系统下如何安装 pandoc。</h2>

<ol>
<li><p>如官网介绍，安装 pandoc
 sudo apt-get install cabal-install
 cabal update
 cabal install pandoc</p></li>
<li><p>添加路径，
 sudo gedit /etc/profile
在打开的文档最后输入
 export PATH=/home/william/.cabal/bin:$PATH
再到
 cd /etc/
 source profile</p></li>
<li><p>再次重新
 cabal install pandoc pandoc-citeproc</p></li>
<li><p>查看是否安装成功
 pandoc --version</p></li>
</ol>

]]></content:encoded>
    </item>
    
    <item>
      <title>Linux 中文输入法（fcitx）安装与设置</title>
      <link>http://williamlfang.github.com/cn/2014/01/08/chinese-input/</link>
      <pubDate>2014-01-08T00:00:00+08:00</pubDate>
      <author>William Fang</author>
      <guid>http://williamlfang.github.com/cn/2014/01/08/chinese-input</guid>
      <content:encoded><![CDATA[<p>Linux （Mint，16 Petra）系统本身并没有默认安装中文输入法。为了在 Linux 操作系统下使用中文输入，需要自己添加。我倒腾了大半天的，终于明白过来这是怎么设置了。现在将全部的过程记录在下面，以备日后使用。</p>

<ol>
<li><p>首先是安装源，</p>

<p> sudo add-apt-repository ppa:fcitx-team/nightly</p></li>
<li><p>更新</p>

<p> sudo apt-get update</p></li>
<li><p>安装 fcitx，搜狗输入法，五笔（一般不用），以及双拼</p>

<p> sudo apt-get install fcitx fcitx-sogoupinyin fcitx-table-wubi fcitx-pinyin</p></li>
<li><p>这个比较重要，可以先在终端输入 fcitx，看看是不是提示没有可用的前端，则需要安装如下 <code>fcitx-frontend-gtk3</code></p>

<p> sudo apt-get install fcitx-frontend-gtk3 fcitx-ui-classic</p></li>
<li><p>打开 fcitx config，如果提示 "fcitx 的 KCModule 未被找到 缺少"，则在Terminator输入</p>

<p> sudo apt-get install kde-config-fcitx</p></li>
<li><p>在 <code>fconfig</code> 设置输入法即可使用。</p></li>
<li><p>需要在 <code>/home</code> 文件夹下面新建/修改 <code>.xprofile</code></p></li>
</ol>


<blockquote><p>export LC_ALL=zh_CN.utf8        <br>
export XMODIFIERS=@im=fcitx        <br>
export QT_IM_MODULE=xim        <br>
export GTK_IM_MODULE=xim        <br>
fcitx -d        <br></p></blockquote>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
