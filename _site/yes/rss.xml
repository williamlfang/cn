<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Life Memory</title>
        <description>Life Memory - ccbikai</description>
        <link>http://miantiao.me</link>
        <lastBuildDate>2014-02-28 03:58:23 +0800</lastBuildDate>
        <pubDate>2014-02-28 03:58:23 +0800</pubDate>
        <ttl>60</ttl>
　     　<copyright>版权所有</copyright>
　　     <language>zh-cn</language>
　     　<generator>nju.pt</generator>


        <item>
                <title>入手NEXUS7 二代</title>
                <description>&lt;p&gt;开学前在V2EX上看到有人求购NEXUS7二代，自己也有点心动，便在回复里找到一个靠谱的，发邮件联系，1000元顺利买到，16G Wi-Fi版本。&lt;br/&gt;
&lt;a href=&quot;http://ww1.sinaimg.cn/large/4eda25f5gw1edtnv1zybuj20dw0afabx.jpg&quot;&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/bmiddle/4eda25f5gw1edtnv1zybuj20dw0afabx.jpg&quot; alt=&quot;Nexus7&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;拿到手打开看成色，很满意，基本可以说是95新。卖家是一个在豆瓣工作的人，猜测是比较文艺的人，机子也会保护的不错，所以才敢大胆下手的。&lt;/p&gt;

&lt;p&gt;拿到手刷机肯定必须的，但是CM汉化的不完全，有点小强迫症，感觉不舒服。就去刷了魔趣的ROM（&lt;a href=&quot;http://download.mfunz.com/?device=flo&quot;&gt;传送门&lt;/a&gt;）,用着很不错。 魔趣是一个开源的ROM,类似于CM，不过是国内开发者。&lt;/p&gt;

&lt;p&gt;原来的酷派5930太卡了，现在可以把里边的应用搬到平板上边了，手机就留着打电话，发短信、微信，聊QQ吧。电子书阅读也搬到平板上边了，搭配多看读电子书很舒服，再也不用担心在手机上看PDF滑来滑去了。&lt;/p&gt;
<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></description>
                <link>http://miantiao.me/nexus-7-two.html</link>
                <guid>http://miantiao.me/nexus-7-two.html</guid>
                <pubDate>2014-02-23 22:02:52 +0800</pubDate>
                <category>扯淡文章</category>
　             　<author>ccbikai</author>
        </item>

        <item>
                <title>诸多事情</title>
                <description>&lt;p&gt;想着有一段时间没有码字了，指尖竟然有些生疏。其实每次打开笔记本，总是想着要有千言万语诉说，那种浓厚的情绪像是一次乘坐列车的远行去拜见一位老友，漫长的路途上早就打好了腹稿构造了完整的画面，可是真正见面了，我们却什么也不说，只是静静的凝望彼此，一言不发。我是有着千般感情万种思绪，却像是失去了老友多年消息总是联系不上了，我愈要赴会，却不知该买到何站的列车。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;此情可待成追忆，只是当时已惘然。&lt;/p&gt;&lt;/blockquote&gt;

&lt;!-- more --&gt;


&lt;h2&gt;一场团圆的春节&lt;/h2&gt;

&lt;p&gt;这个春节过得平淡，安静的出奇。本来嘛，厦门就是一个旅游的城市，人来人往，车水马龙，热闹喧嚣，浮华尘世，这个本该就是这座城市的标志。可是真正到了春节，却也少了人，不见了往日的喧嚣。这座城市一下子变得可爱，如含蓄的姑娘，像待放的花苞，羞羞答答的。大抵是政府的规定只为贪图省事（baoli zhifa），我们的城市在春节期间竟然不允许燃放烟花。只是冷冷清清的城市，在这个孤孤单单的季节里，多少显得有点委屈。&lt;/p&gt;

&lt;p&gt;不过几日的天气倒是也好。阳光灿烂如孩童的笑脸天真无瑕，暖心的却不热烈，滑落在皮肤生怕破碎。有一天猪头提议全家动身前去东坪山晒太阳，只为了这一刻的阳光弥足珍贵。是啊，往前每每在老家过年，春节这几天几乎都是阴雨连天，难得的出现这么晴朗的天气。南方的小渔村更添了几分冷意，空气了充斥了水气的冰冻，像是凝结的薄幕。更有那些象征喜庆的鞭炮在燃放过后四处挥舞的烟雾，掺杂在冰晶的半空，久久不散，犹如仙境。一个人常年在外旅居，此刻见了这般景象，竟有一些感伤，仿佛这是一股催泪剂，流浪的酸楚与归家的喜悦一齐涌上眼角，润湿了眼眶。&lt;/p&gt;

&lt;p&gt;今天春节并没有回老家过春节。年前和猪头商量了一下，决定邀请家中两位老人来厦团聚。一来是我们也没有那么多时间，本来她的假期就少得可怜，这来来回回的在路上费的时间多，也够折腾人（航班经常改道，火车时而晚点），小咪豆也不大适合舟车劳顿，怕了出了漏子；二来，我们也想让老人家出来走走，毕竟厦门这个春节的天气真的是好的惹人疼爱，招人喜欢，而且在这边我们两个都比较熟悉，平时出来旅游吃饭都挺方便的。于是乎，我们家今年便最终在厦门团聚了。&lt;/p&gt;

&lt;h2&gt;一次未行的聚会&lt;/h2&gt;

&lt;p&gt;掐指一算，现在离初中毕业已经十年了。十年可算是一个大时期，我从一个毛头小伙子到一个丈夫与一个孩子的父亲。走过的这十年，一直都坎坎坷坷，曲曲折折。人生本当如此，历经风雨，奋斗不止，在晚年回首方有可念之处。可是这十年来，我总是那么的羡慕当初的那个纯真的孩子，一脸惘然的朝向未知的旅途，却也满心的勇气。&lt;/p&gt;

&lt;p&gt;初中的校园坐落在一个海滩湾处。小，而且年代久远，当时又正值人口峰值，我们的学校里竟然漫漫的都是人。这业已脱离了我对学校的概念，原先的小学人少，地大，小伙伴们总是有各种玩趣之地可去。可是现在，我只能在教室里待着，不能出去，稍不小心，便有人在走廊里撞到了。在这个拥挤甚至可以说是臃肿的校园里，我却感到无尽的孤单。人与人的会面，往往加深了心与心的分裂。愈多的人，愈感孤单。这种在人多之处说体会到的孤单，长年累月的陪伴着我，阴魂不散，挥之不去。&lt;/p&gt;

&lt;p&gt;初中唯一让我着迷的事情，是数学课本里那些由符号与方程编写而成的美丽世界。它们像极了天际线在昏黄夜晚的轮廓，淡淡的泛着氤氲。很多时候，我愿凝视这个虚无缥缈却深埋心底的幻城，痴痴的美梦着，想要得到那个神秘的答案。&lt;/p&gt;

&lt;p&gt;无数的小时里，我把自己深埋在那些符号里，不吭一声。我的这种孤傲与孤单，将周边的同学都隔离起来了，不再联系。其实，我只是不说一句话；其实，我只是一直都孤单着。&lt;/p&gt;

&lt;p&gt;很多的年头里，我不曾与我的那些小伙伴们联络。&lt;/p&gt;

&lt;p&gt;今年突然听娜姐给我电话（我也不知她何来家里的号码），说是春节会有同学聚会，毕竟许多人已经不见整十年，希望此次可以相聚会面。可是，这次命运又在捉弄玩笑，今年正值全家都齐来厦门团聚，并没有计划会老家。而家中尚有小咪豆需要照顾，故而此次聚会也无奈不能成行。&lt;/p&gt;

&lt;h2&gt;一个未果的问题&lt;/h2&gt;

&lt;p&gt;有一个悬而未解的问题，未果，不便诉说。&lt;/p&gt;
<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></description>
                <link>http://miantiao.me/zhu-duo-shi-qing.html</link>
                <guid>http://miantiao.me/zhu-duo-shi-qing.html</guid>
                <pubDate>2014-02-12 00:00:00 +0800</pubDate>
                <category>yes</category>
　             　<author>ccbikai</author>
        </item>

        <item>
                <title>美联储的「博士系」</title>
                <description>&lt;p&gt;下午在浏览『华尔街见闻』的时候正好看到了这样一篇有意思的文章，大致介绍了美联储是如何从一个由实干家（如银行家与金融巨头）组成的俱乐部升级成由一帮&lt;a href=&quot;http://wallstreetcn.com/node/75851&quot;&gt;经济学博士引领的「学院派」&lt;/a&gt;。文章写的条理比较清楚的了，从成员的学位背景出发梳理了美联储的发展历程。诸位如果感兴趣可以前去看看。我这里主要是提供一个个人的随想而已。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;首先来一个「全家福」吧。
&lt;img src=&quot;/cn/assets/images/r-figures/2014-02-12-mei-lian-chu-de-bo-shi-xi/fed.jpg&quot; alt=&quot;the fed&quot; /&gt;&lt;/p&gt;

&lt;p&gt;文章谈到了对美联储决策有重要影响的几位「高官」的学历背景。目前新晋美联储主席的耶伦（Yellen）拥有 Yale 经济学博士学历，其在学术界有颇有建树。而那些身处高职的几位委员会成员（&lt;strong&gt;FOMC&lt;/strong&gt;）均配有经济学博士学位，如 Stanley Fischer 就是前 &lt;strong&gt;IMF&lt;/strong&gt; 的首席经济学家 [^1] 。而如果从历史的纵向来看，这个趋势就更加明显了：沃尔克当时还只是经济学硕士，到了格林斯潘后来获得博士学位，而前任伯南克就已经是一名正式的大学（宏观）经济学教授了。Blinder 是原 &lt;strong&gt;FOMC&lt;/strong&gt; 委员，他对 &lt;strong&gt;Fed&lt;/strong&gt; 的历史颇有研究，宣称：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;我相信，当时在美联储80年的历史中，我是第四个或第五个学院派委员。不久后耶伦也来了，然后学院派就开始蜂拥而入。如今，这是一个很正常的现象，而且学院派教授更受欢迎。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;中国有古语说『物以类聚，人以群分』，这个自然界的普遍真理同样适用于经济学界。我们经常看到持有不同观点的学派之间是如何明争暗斗的，比如早些年的世纪大战——凯恩斯与哈耶克的论战，到后来由弗里德曼扛旗的货币主义学派反攻凯恩斯主义阵营。有些时候我真就觉得经济学这个大火锅里搅拌的是娱乐圈的废料，「你方唱罢我来和」，不无热闹，却全无一点增进人民福祉的实景。&lt;/p&gt;

&lt;p&gt;当初成立美联储的初衷是为了结束美国国内混乱的金融秩序，统一由一个中央决策机构来制定、执行货币政策。因此，当初在位掌权的一般都是一些银行家与金融巨头，大家都比较注重实干，以直觉和经验取胜，很少能寻觅到经济学院派的作风。&lt;/p&gt;

&lt;p&gt;物是人非，斗转星移，我们现在看到美联储的境况，清一色的由理论界与学院派占山为王，并且在将来的很长一段时间内，这样的趋势会进一步明显。这些成员一般都具有良好的经济学训练，取得正规的博士学位，而且绝大部分还有过学术研究的经历，在各自的领域都有不小的影响力。如前任伯南克，在研究经济萧条理论、商业周期、宏观经济与失业率等诸多方面颇有成就。下面这幅图揭示了在美联储长达一个世纪的演变过程中，成员学术能力的提升。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/cn/assets/images/r-figures/2014-02-12-mei-lian-chu-de-bo-shi-xi/position.jpg&quot; alt=&quot;position&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就美联储成员在学位背景上不断更新的情况来分析，文章是这样认为的：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;美联储拥有越来越多的博士可能是件好事。一个只有经济学博士担任高级职位的美联储将有很多局限。多元化会带来各种正面效应，单一文化则会脆弱和不健康。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;我的想法是，今后金融实务界能够更好的预测到美联储的决策机制了。在以前，美联储在公开市场的决策与操作动机基本是一个黑盒子，外界无从知晓。到了上世纪70年代，美联储才开始注重与大众的沟通，定期的发布公告向金融市场传送消息，并且在独立性方面获得了巨大的改善。可是外界在对美联储的决策进行拿捏把握上依然小心谨慎，如履薄冰。这归根到底还是因为美联储的决策机制不够开放，无法面向外界提供所有的内部信息。而正是这种信息上的不对称，导致每次在美联储闭门研讨经济决策的前后时期均可看到明显的市场波动，伤害经济的稳健。&lt;/p&gt;

&lt;p&gt;而现在，我们可以从美联储成员的组成结构上获得一定的「启发」。不同的经济学理论在针对同样一个经济问题时提供的解决方案千差万别，有时甚至是南辕北辙，背道而驰。因此，我们可以借助对美联储组成成员的经济理论主张上分析其未来的决策风格与指导理论，从而在一定程度上透析美联储这个神秘的机构。我的建议时，当前的市场参与者还是需要对新一届的美联储决策机构多做一些「功课」，以便深入了解其决策特征，从而更好的预测与把握美联储在今后制定的各项经济政策。&lt;/p&gt;

&lt;p&gt;当然，我们也可以从另外一个方面看问题。就是如果美联储的成员构成正的过于学院派，那么其在应对更加具体的金融事件上，可能不会从金融实务界的形势出发，或者干脆就忽视了那些真正需要解决问题的方案的银行家的呼声。这对美联储今后的决策有效性不得不大打折扣，甚至在某些时候反而会伤害实际经济的健康发展。纯粹由经济理论模型提出的药方往往不能够良好的「接地气」，反而挫伤实体经济的积极性。&lt;/p&gt;

&lt;p&gt; [^1] Fischer 也是学术界的大牛，和 Blanchard 共同著有“Lectures on Macroeconomcis”，红极一时，可谓那个时代的标准 &lt;em&gt;textbook&lt;/em&gt;。&lt;/p&gt;
<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></description>
                <link>http://miantiao.me/mei-lian-chu-de-bo-shi-xi.html</link>
                <guid>http://miantiao.me/mei-lian-chu-de-bo-shi-xi.html</guid>
                <pubDate>2014-02-12 00:00:00 +0800</pubDate>
                <category>经济分析</category>
　             　<author>ccbikai</author>
        </item>

        <item>
                <title>美联储的「博士系」</title>
                <description>&lt;p&gt;下午在浏览『华尔街见闻』的时候正好看到了这样一篇有意思的文章，大致介绍了美联储是如何从一个由实干家（如银行家与金融巨头）组成的俱乐部升级成由一帮&lt;a href=&quot;http://wallstreetcn.com/node/75851&quot;&gt;经济学博士引领的「学院派」&lt;/a&gt;。文章写的条理比较清楚的了，从成员的学位背景出发梳理了美联储的发展历程。诸位如果感兴趣可以前去看看。我这里主要是提供一个个人的随想而已。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;首先来一个「全家福」吧。
&lt;a href=&quot;/cn/assets/images/r-figures/2014-02-12-mei-lian-chu-de-bo-shi-xi/fed.jpg&quot;&gt;&lt;img src=&quot;/cn/assets/images/r-figures/2014-02-12-mei-lian-chu-de-bo-shi-xi/fed.jpg&quot; alt=&quot;the fed&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文章谈到了对美联储决策有重要影响的几位「高官」的学历背景。目前新晋美联储主席的耶伦（Yellen）拥有 Yale 经济学博士学历，其在学术界有颇有建树。而那些身处高职的几位委员会成员（&lt;strong&gt;FOMC&lt;/strong&gt;）均配有经济学博士学位，如 Stanley Fischer 就是前 &lt;strong&gt;IMF&lt;/strong&gt; 的首席经济学家 [^1] 。而如果从历史的纵向来看，这个趋势就更加明显了：沃尔克当时还只是经济学硕士，到了格林斯潘后来获得博士学位，而前任伯南克就已经是一名正式的大学（宏观）经济学教授了。Blinder 是原 &lt;strong&gt;FOMC&lt;/strong&gt; 委员，他对 &lt;strong&gt;Fed&lt;/strong&gt; 的历史颇有研究，宣称：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;我相信，当时在美联储80年的历史中，我是第四个或第五个学院派委员。不久后耶伦也来了，然后学院派就开始蜂拥而入。如今，这是一个很正常的现象，而且学院派教授更受欢迎。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;中国有古语说『物以类聚，人以群分』，这个自然界的普遍真理同样适用于经济学界。我们经常看到持有不同观点的学派之间是如何明争暗斗的，比如早些年的世纪大战——凯恩斯与哈耶克的论战，到后来由弗里德曼扛旗的货币主义学派反攻凯恩斯主义阵营。有些时候我真就觉得经济学这个大火锅里搅拌的是娱乐圈的废料，「你方唱罢我来和」，不无热闹，却全无一点增进人民福祉的实景。&lt;/p&gt;

&lt;p&gt;当初成立美联储的初衷是为了结束美国国内混乱的金融秩序，统一由一个中央决策机构来制定、执行货币政策。因此，当初在位掌权的一般都是一些银行家与金融巨头，大家都比较注重实干，以直觉和经验取胜，很少能寻觅到经济学院派的作风。&lt;/p&gt;

&lt;p&gt;物是人非，斗转星移，我们现在看到美联储的境况，清一色的由理论界与学院派占山为王，并且在将来的很长一段时间内，这样的趋势会进一步明显。这些成员一般都具有良好的经济学训练，取得正规的博士学位，而且绝大部分还有过学术研究的经历，在各自的领域都有不小的影响力。如前任伯南克，在研究经济萧条理论、商业周期、宏观经济与失业率等诸多方面颇有成就。下面这幅图揭示了在美联储长达一个世纪的演变过程中，成员学术能力的提升。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/cn/assets/images/r-figures/2014-02-12-mei-lian-chu-de-bo-shi-xi/position.jpg&quot; alt=&quot;position&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就美联储成员在学位背景上不断更新的情况来分析，文章是这样认为的：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;美联储拥有越来越多的博士可能是件好事。一个只有经济学博士担任高级职位的美联储将有很多局限。多元化会带来各种正面效应，单一文化则会脆弱和不健康。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;我的想法是，今后金融实务界能够更好的预测到美联储的决策机制了。在以前，美联储在公开市场的决策与操作动机基本是一个黑盒子，外界无从知晓。到了上世纪70年代，美联储才开始注重与大众的沟通，定期的发布公告向金融市场传送消息，并且在独立性方面获得了巨大的改善。可是外界在对美联储的决策进行拿捏把握上依然小心谨慎，如履薄冰。这归根到底还是因为美联储的决策机制不够开放，无法面向外界提供所有的内部信息。而正是这种信息上的不对称，导致每次在美联储闭门研讨经济决策的前后时期均可看到明显的市场波动，伤害经济的稳健。&lt;/p&gt;

&lt;p&gt;而现在，我们可以从美联储成员的组成结构上获得一定的「启发」。不同的经济学理论在针对同样一个经济问题时提供的解决方案千差万别，有时甚至是南辕北辙，背道而驰。因此，我们可以借助对美联储组成成员的经济理论主张上分析其未来的决策风格与指导理论，从而在一定程度上透析美联储这个神秘的机构。我的建议时，当前的市场参与者还是需要对新一届的美联储决策机构多做一些「功课」，以便深入了解其决策特征，从而更好的预测与把握美联储在今后制定的各项经济政策。&lt;/p&gt;

&lt;p&gt;当然，我们也可以从另外一个方面看问题。就是如果美联储的成员构成正的过于学院派，那么其在应对更加具体的金融事件上，可能不会从金融实务界的形势出发，或者干脆就忽视了那些真正需要解决问题的方案的银行家的呼声。这对美联储今后的决策有效性不得不大打折扣，甚至在某些时候反而会伤害实际经济的健康发展。纯粹由经济理论模型提出的药方往往不能够良好的「接地气」，反而挫伤实体经济的积极性。&lt;/p&gt;

&lt;p&gt; [^1] Fischer 也是学术界的大牛，和 Blanchard 共同著有“Lectures on Macroeconomcis”，红极一时，可谓那个时代的标准 &lt;em&gt;textbook&lt;/em&gt;。&lt;/p&gt;
<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></description>
                <link>http://miantiao.me/mei-lian-chu-de-bo-shi-xi.html</link>
                <guid>http://miantiao.me/mei-lian-chu-de-bo-shi-xi.html</guid>
                <pubDate>2014-02-12 00:00:00 +0800</pubDate>
                <category>yes</category>
　             　<author>ccbikai</author>
        </item>

        <item>
                <title>祝大家新年快乐</title>
                <description>&lt;p&gt;&lt;strong&gt;祝大家在新的一年里写代码没有BUG，事事顺心。&lt;/strong&gt;&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;昨晚给in笔记的所有评论者用插件群发了一封邮件。但是Lifememory Memory是读者却没有办法拿出邮件列表，后来想到了多说，导出评论的备份，然后用python提取出来邮箱地址。  扔一个Gists，需要的朋友自己拿。https://gist.github.com/ccbikai/8725349&lt;br/&gt;
&lt;a href=&quot;http://ww1.sinaimg.cn/large/4eda25f5jw1ed20ekrnetj20hs0hs78u.jpg&quot;&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/bmiddle/4eda25f5jw1ed20ekrnetj20hs0hs78u.jpg&quot; alt=&quot;多说&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;邮件发送用的是sendcloud和mailgun,sendcloud一个账号每天可以发生300封，然后mailgun，每个域名可以发送300封。不过sendcloud在国内的到达率高，毕竟是国内的公司。&lt;/p&gt;

&lt;p&gt;邮件发送时候做错两件事，一是in笔记和Life Memory的前300封邮件没有留博客地址，可能让大家都不知道是谁。还有一个严重的是，对mailgun不熟悉，不知道它群发里边会有所有邮箱地址，所以在大家的邮箱收件人里边好多邮箱，泄露了大家的邮箱地址，对大家说声对不起。下次发邮件一定调整代码，一封一封发送。&lt;/p&gt;

&lt;p&gt;还有最近热火的微信红包，我一个都没有收到，难道我微信好友圈都是屌丝？&lt;/p&gt;
<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></description>
                <link>http://miantiao.me/happy-chinese-year-2014.html</link>
                <guid>http://miantiao.me/happy-chinese-year-2014.html</guid>
                <pubDate>2014-01-31 10:11:33 +0800</pubDate>
                <category>扯淡文章</category>
　             　<author>ccbikai</author>
        </item>

        <item>
                <title>宅</title>
                <description>&lt;p&gt;不知不觉，寒假的一半已经过完，看书计划也没有跟得上，而且还给自己挖了好多坑。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;不知道为什么今年寒假不喜欢出门了，几乎也没有找同学去玩，整体宅在家里连门也不出，真是大门不出二门不迈啊。我记得以前假期总爱出去玩了，难道是越长大越孤单了？&lt;/p&gt;

&lt;p&gt;本来计划回家多看看书的，而且还给自己布置了几个任务，可是书看了两天就不看了，然后就玩起了手机。家里没网，所以流量早早就用光了，只能去淘宝买一张流量卡。暑假的时候9G的流量卡只要50多，可是现在过年就要100多了，翻了整整一倍啊。家里边联通的速度还不错，能达250+K/s,感觉已经满足了。可是我手机是电信的，还是没有流量玩。电脑共享了无线网络，但是手机连上就是上不了网，不知道是不是联通网卡的原因。最后尝试了好多方法，用代理的办法解决了。 电脑上装shadowssockes客户端，然后本地的1991端口就是局域网一个代理了，手机上用ProxyDroid连接代理，设置为全局代理，手机就可以上网了。由于电脑的shadowsocke连接的是国外的服务器，手机上直接可以上推了，感觉还挺爽。&lt;/p&gt;

&lt;p&gt;这些天一直在看&lt;a href=&quot;http://www.zhihu.com/people/ccbikai&quot;&gt;知乎&lt;/a&gt;，越看越感到自己知道的少。没事的时候整理了一下RSS订阅，折腾了一下手机，给浏览器多装了几个插件，有时间写出来推荐一下。&lt;/p&gt;

&lt;p&gt;想必好多人过年会被别人喊去修电脑，不想修的，你可以给装了Linux系统，以后再也不会找你修了。&lt;/p&gt;

&lt;p&gt;马上就要过年了，给大家送个春节&lt;a href=&quot;http://www.meiziweibo.com/&quot;&gt;小福利&lt;/a&gt;，记得点赞噢！&lt;/p&gt;
<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></description>
                <link>http://miantiao.me/homebody.html</link>
                <guid>http://miantiao.me/homebody.html</guid>
                <pubDate>2014-01-28 11:50:17 +0800</pubDate>
                <category>扯淡文章</category>
　             　<author>ccbikai</author>
        </item>

        <item>
                <title>Data Structure</title>
                <description>&lt;p&gt;这一章主要介绍了在 &lt;strong&gt;R&lt;/strong&gt; 中最基本的元素：数据。前段时间我在网上看到一个帖子（暂时忘记在哪里找到了），强调「data science」的重心不是在前面的那个「data」，而是后面的「science」。这是因为随着互联网的深入发展，我们现在不再是缺乏数据，反而是面临着「big data」造成的「information rich」（信息冗余）的困扰。因此，今后的数据科学应当更进一步的发展新的理论与方法来解决大数据分析。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;好了，这个扯远了。不过在 &lt;strong&gt;R&lt;/strong&gt; 中，我们最紧要的事情就是：给了一大箩筐的数据，可能是排列完整的，不过大多数情况下是混乱不堪的，要求对这些数据做统计分析与可视化工作。这个基本上是一件既头疼又心烦的苦差事。首先的任务是，先对这些数据做一定格局的处理，得到我们后续需要使用的信息变量。因此，熟练掌握处理数据的基本方法，对未来的分析至关重要。&lt;/p&gt;

&lt;h2&gt;概览&lt;/h2&gt;

&lt;p&gt;Wickham 用一张表格总结了 &lt;strong&gt;R&lt;/strong&gt; 中的数据结构&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;R's base data structures are summarised in the table below, organised by their dimensionality and whether they're homogeneous (all contents must be of the same type) or heterogeneous (the contents can be of different types):&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;    &lt;/th&gt;
&lt;th&gt; Homogeneous   &lt;/th&gt;
&lt;th&gt; Heterogeneous &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; 1d &lt;/td&gt;
&lt;td&gt; Atomic vector &lt;/td&gt;
&lt;td&gt; List          &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 2d &lt;/td&gt;
&lt;td&gt; Matrix        &lt;/td&gt;
&lt;td&gt; Data frame    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; nd &lt;/td&gt;
&lt;td&gt; Array         &lt;/td&gt;
&lt;td&gt;               &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;

&lt;p&gt;需要解释的是标量（scalar）。什么是标量呢？就是一个个单独的变量，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- 5
y &amp;lt;- &quot;scalar&quot;

x

## [1] 5

y

## [1] &quot;scalar&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;R&lt;/strong&gt; 默认地将标量识别为 1*1 的向量（vector），也就是 0-dimensional。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;这里科普一下有关 &lt;strong&gt;R&lt;/strong&gt; 中的面向对象的特征。也就是说， &lt;strong&gt;R&lt;/strong&gt; 中所有的元素都可以叫做「对象」（obgect），这不仅仅是基本的数据，如向量、data frame，还包括函数（function）、环境（environment），甚至是符号（symbols）。 &lt;strong&gt;R&lt;/strong&gt; 处理完分析后得到的就是一个对象，我们需要哪儿元素，直接提取就可以了。比如，&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    df = data.frame(x = rnorm(100, 0, 1), y = seq(from = 1, to = 100))
    result &amp;lt;- lm(y ~ x, data = df)

    result

    ## 
    ## Call:
    ## lm(formula = y ~ x, data = df)
    ## 
    ## Coefficients:
    ## (Intercept)            x  
    ##       51.01         3.01
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;得到的结果存储在 &lt;code&gt;result&lt;/code&gt; 里，这个就是一个对象，等到我们需要使用其中的「子对象」时，再从中提取即可&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    result$coeff

    ## (Intercept)           x 
    ##      51.005       3.007
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;面向对象的编程能够提供非常灵活的数据处理结果，并且具有较高的程序维护性。这在 &lt;strong&gt;R&lt;/strong&gt; 得到了极大的展现。&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;str()&lt;/code&gt;：查看数据结构&lt;/h3&gt;

&lt;p&gt;查看数据类型可以使用命令 &lt;code&gt;str()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;str(df)

## 'data.frame':    100 obs. of  2 variables:
##  $ x: num  0.659 0.277 0.614 -0.655 -0.896 ...
##  $ y: int  1 2 3 4 5 6 7 8 9 10 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;向量&lt;/h2&gt;

&lt;p&gt;如上所述， &lt;strong&gt;R&lt;/strong&gt; 中主要的一维数据类型包括 &lt;code&gt;atomic vector&lt;/code&gt;（基础向量） 和 &lt;code&gt;list&lt;/code&gt;（列表），前者要求罗列其中的数据均是同属性的，比如 &lt;code&gt;logical&lt;/code&gt;，&lt;code&gt;interger&lt;/code&gt;，&lt;code&gt;double&lt;/code&gt;，和 &lt;code&gt;character&lt;/code&gt;。而后者 &lt;code&gt;list&lt;/code&gt; 则可以是多种数据类型的混合。&lt;/p&gt;

&lt;h3&gt;基础向量&lt;/h3&gt;

&lt;p&gt;基础向量是组成 &lt;strong&gt;R&lt;/strong&gt; 编程语言的基石，可以由此构成其他类型的数据结构。怎么去理解  &lt;strong&gt;R&lt;/strong&gt; 中的向量呢？&lt;/p&gt;

&lt;h4&gt;数据的向量化&lt;/h4&gt;

&lt;p&gt;其实，这个可以看作是一个研究变量的序列观测值。比如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- c(35.6, 36.1, 35.8, 37, 36.5, 37.2, 35.8)
str(x)

##  num [1:7] 35.6 36.1 35.8 37 36.5 37.2 35.8

is.vector(x)

## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个就是一个向量，可以视为一天中在七个不同时间段的气温观测。因此，我们可以利用这个向量来产生矩阵，从而实现多元变量在不同时间序列上的观测值。其实，这种数据的向量化不仅提供了对数据的直观理解，而且还能提高 &lt;strong&gt;R&lt;/strong&gt; 的运算速度，尽量避免使用循环，优化程序。这点我们在日后会继续讨论。&lt;/p&gt;

&lt;h4&gt;生成向量的方法&lt;/h4&gt;

&lt;p&gt;用于生成向量的命令主要有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;c()&lt;/code&gt;:即「concantinate」的意思，用于生成一个向量，并且可用于嵌套&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  a &amp;lt;- c(1, 2, 4, 6, 8)
  b &amp;lt;- c(1, c(2, c(4, 6.8)))  # 套嵌使用
  a == b

  ## Warning: longer object length is not a multiple of shorter object length

  ## [1]  TRUE  TRUE  TRUE FALSE FALSE


  s &amp;lt;- c(1:10)  # 一个序列。相当于 seq(from = 1, to = 10, by= 1)
  s

  ##  [1]  1  2  3  4  5  6  7  8  9 10


  int &amp;lt;- c(1L, 6L, 8L)  # 产生integer类

  log &amp;lt;- c(T, F, F, T, T)  # logical

  chr &amp;lt;- c(&quot;these&quot;, &quot;are&quot;, &quot;some&quot;, &quot;character&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;seq()&lt;/code&gt;:即「sequence」的意思，主要用于产生一个带有规律的序列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  f &amp;lt;- seq(1:10)  # 默认的increament是1,相当于 c(1:10)
  f

  ##  [1]  1  2  3  4  5  6  7  8  9 10


  g &amp;lt;- seq(from = 1, to = 10, by = 0.5)

  g

  ##  [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5
  ## [15]  8.0  8.5  9.0  9.5 10.0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;rep()&lt;/code&gt;:即[replecate],重复某个数或者某个「序列」，可用于产生较为复杂的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  h &amp;lt;- rep(5, 10)  # 单个数字的重复
  h

  ##  [1] 5 5 5 5 5 5 5 5 5 5


  j &amp;lt;- rep(c(1:3), 3)  # 重复一个序列 c(1:3)
  j

  ## [1] 1 2 3 1 2 3 1 2 3
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;rnorm()&lt;/code&gt;:产生随机数，还有其他的分布&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  k &amp;lt;- rnorm(100)  #default：rnorm(no, mean = 0, sd = 1)

  l &amp;lt;- rnorm(100, mean = 2, sd = 5)
  plot(density(l))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;img src=&quot;/cn/assets/images/r-figures/2014-01-26-data-structure/unnamed-chunk-9.png&quot; alt=&quot;plot of chunk unnamed-chunk-9&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;类型与长度&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;typeof()&lt;/code&gt; 用于查看数据类型，而 &lt;code&gt;length()&lt;/code&gt; 则用于查看向量长度：如果是一维数据，则给出长度；如果是矩阵或者 &lt;code&gt;data.frame&lt;/code&gt;，则给出 &lt;code&gt;nrow&lt;/code&gt; 与 &lt;code&gt;ncol&lt;/code&gt; 的合计。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- rnorm(100)
typeof(x)

## [1] &quot;double&quot;

length(x)

## [1] 100


y &amp;lt;- c(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;)
typeof(y)

## [1] &quot;character&quot;

length(y)

## [1] 3


z &amp;lt;- c(T, T, F)
typeof(z)

## [1] &quot;logical&quot;

length(z)

## [1] 3


w &amp;lt;- seq(from = 1, to = 10, by = 1)
typeof(w)

## [1] &quot;double&quot;

length(w)

## [1] 10


mat &amp;lt;- matrix(rnorm(20), nrow = 4, ncol = 5)
typeof(mat)

## [1] &quot;double&quot;

length(mat)

## [1] 20
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;code&gt;list&lt;/code&gt;:列表&lt;/h3&gt;

&lt;p&gt;我们已经知道，&lt;code&gt;vector&lt;/code&gt;是用于同种类型属性的数据，而&lt;code&gt;list&lt;/code&gt;则适用于不同类型的数据，可以说是各种数据的一个「大火锅」。我们使用&lt;code&gt;list()&lt;/code&gt;来生成数据，不是之前介绍的&lt;code&gt;c()&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;u &amp;lt;- list(1:3, &quot;cha&quot;, T, F, c(1, 4, 7), rep(1, 3), seq(1:5))

u

## [[1]]
## [1] 1 2 3
## 
## [[2]]
## [1] &quot;cha&quot;
## 
## [[3]]
## [1] TRUE
## 
## [[4]]
## [1] FALSE
## 
## [[5]]
## [1] 1 4 7
## 
## [[6]]
## [1] 1 1 1
## 
## [[7]]
## [1] 1 2 3 4 5

str(u)

## List of 7
##  $ : int [1:3] 1 2 3
##  $ : chr &quot;cha&quot;
##  $ : logi TRUE
##  $ : logi FALSE
##  $ : num [1:3] 1 4 7
##  $ : num [1:3] 1 1 1
##  $ : int [1:5] 1 2 3 4 5

typeof(u)

## [1] &quot;list&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，&lt;code&gt;list&lt;/code&gt;也可以跟&lt;code&gt;c()&lt;/code&gt;一样实现套嵌 (Wickham称之为[recursive])&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;v &amp;lt;- list(list(2, 4, T, &quot;nope&quot;, seq(4:8)), rep(3:4, 2), list(T, F, &quot;yes&quot;))
v

## [[1]]
## [[1]][[1]]
## [1] 2
## 
## [[1]][[2]]
## [1] 4
## 
## [[1]][[3]]
## [1] TRUE
## 
## [[1]][[4]]
## [1] &quot;nope&quot;
## 
## [[1]][[5]]
## [1] 1 2 3 4 5
## 
## 
## [[2]]
## [1] 3 4 3 4
## 
## [[3]]
## [[3]][[1]]
## [1] TRUE
## 
## [[3]][[2]]
## [1] FALSE
## 
## [[3]][[3]]
## [1] &quot;yes&quot;


str(v)

## List of 3
##  $ :List of 5
##   ..$ : num 2
##   ..$ : num 4
##   ..$ : logi TRUE
##   ..$ : chr &quot;nope&quot;
##   ..$ : int [1:5] 1 2 3 4 5
##  $ : int [1:4] 3 4 3 4
##  $ :List of 3
##   ..$ : logi TRUE
##   ..$ : logi FALSE
##   ..$ : chr &quot;yes&quot;

typeof(v)

## [1] &quot;list&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;factors:因子&lt;/h3&gt;

&lt;p&gt;因子也是一种向量类型，不过在因子里面，我们需要预先设定好水平值。换句话说，因子有两个属性特者&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;class（类型)：也就是 &lt;code&gt;factor&lt;/code&gt;，使用命令 &lt;code&gt;class()&lt;/code&gt; 来查看。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;level (层级)：表明因子有哪些不同取值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- factor(c(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;))
x

## [1] a b b a
## Levels: a b

class(x)

## [1] &quot;factor&quot;

levels(x)

## [1] &quot;a&quot; &quot;b&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;矩阵&lt;/h2&gt;

&lt;p&gt;前面我们解释过如何看待向量（vector）作为一个研究变量的观测，那么，一个有多祖向量组成的矩阵（&lt;strong&gt;Matrix&lt;/strong&gt;）就可以被视为是一个多元变量的观测。每一个列向量表示一个变量，而每一个行向量则表示一次的观测结果。这样，我们便可以将其与多元统计结合在一起理解了。&lt;/p&gt;

&lt;h3&gt;创建矩阵&lt;/h3&gt;

&lt;p&gt;由于矩阵是一个带有二维属性的数据列表，我们在创建矩阵时需要设定矩阵的行与列数目。表示矩阵列向量数据的是命令 &lt;code&gt;ncol&lt;/code&gt;, 相应的，行数目的是 &lt;code&gt;nrow&lt;/code&gt;。具体的方法有&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;预先设定好行列数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; mat01 &amp;lt;- matrix(1:10, ncol = 2, nrow = 5)

 mat01

 ##      [,1] [,2]
 ## [1,]    1    6
 ## [2,]    2    7
 ## [3,]    3    8
 ## [4,]    4    9
 ## [5,]    5   10
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用命令 &lt;code&gt;dim()&lt;/code&gt; 设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; mat02 &amp;lt;- matrix(1:10)
 dim &amp;lt;- c(2, 5)

 mat02

 ##       [,1]
 ##  [1,]    1
 ##  [2,]    2
 ##  [3,]    3
 ##  [4,]    4
 ##  [5,]    5
 ##  [6,]    6
 ##  [7,]    7
 ##  [8,]    8
 ##  [9,]    9
 ## [10,]   10
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;矩阵的行列名称&lt;/h3&gt;

&lt;p&gt;有时候，我们需要指定矩阵当中的行列名称，就像在 &lt;strong&gt;Excel&lt;/strong&gt; 里面有表头一样。这样可以通过命令来完成&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;colnames&lt;/code&gt;：列名称。可以看作是不同的研究变量，比如在多元回归里面的不同影响因素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; mat03 &amp;lt;- matrix(1:15, ncol = 3, nrow = 5)

 mat03

 ##      [,1] [,2] [,3]
 ## [1,]    1    6   11
 ## [2,]    2    7   12
 ## [3,]    3    8   13
 ## [4,]    4    9   14
 ## [5,]    5   10   15


 colnames(mat03) &amp;lt;- c(&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;)  # 三个研究变量

 mat03

 ##      x1 x2 x3
 ## [1,]  1  6 11
 ## [2,]  2  7 12
 ## [3,]  3  8 13
 ## [4,]  4  9 14
 ## [5,]  5 10 15
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;rownams&lt;/code&gt;：行名称，算作一次的截面数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; mat04 &amp;lt;- matrix(1:15, ncol = 5, nrow = 3)

 mat04

 ##      [,1] [,2] [,3] [,4] [,5]
 ## [1,]    1    4    7   10   13
 ## [2,]    2    5    8   11   14
 ## [3,]    3    6    9   12   15


 rownames(mat04) &amp;lt;- c(&quot;obs01&quot;, &quot;obs02&quot;, &quot;obs03&quot;)

 mat04

 ##       [,1] [,2] [,3] [,4] [,5]
 ## obs01    1    4    7   10   13
 ## obs02    2    5    8   11   14
 ## obs03    3    6    9   12   15
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Data Frames：数据框&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Data Frame&lt;/strong&gt; 可以说是 &lt;strong&gt;R&lt;/strong&gt; 中最重要的数据类型了，一方面，既具有向量的特征，表示同样长度的变量数据，另一方面，还保持了 &lt;code&gt;list&lt;/code&gt; 中对不同类型数据的支持。这个也是我们做计量经济分析主要用到的数据结构。&lt;strong&gt;Data Frame&lt;/strong&gt; 在很多的方面都与 &lt;strong&gt;matrix&lt;/strong&gt; 相似，比如 &lt;code&gt;colnames&lt;/code&gt;, &lt;code&gt;dim&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;建立 dataframe&lt;/h3&gt;

&lt;p&gt;建立 &lt;strong&gt;Data Frame&lt;/strong&gt; 的命令是 &lt;code&gt;data.frame&lt;/code&gt;，要求是行数目要相同，列向量允许不同类型的数据。比如，有一个数据是这样的，第一个为姓名，第二个是性别，接着是收入，受教育年限，等等。这些都可以在 &lt;strong&gt;Data Frame&lt;/strong&gt; 共存。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;df &amp;lt;- data.frame(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;))

df

##   x y
## 1 1 a
## 2 2 b
## 3 3 c
## 4 4 d
## 5 5 e


str(df)

## 'data.frame':    5 obs. of  2 variables:
##  $ x: int  1 2 3 4 5
##  $ y: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有一点需要特别注意，&lt;strong&gt;R&lt;/strong&gt; 会默认在数据框里面将字符型（string)转化为因子（factor），如果不想要转化，可以通过参数 &lt;code&gt;stringsAsFactors = FALSE&lt;/code&gt; 来设置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;df_02 &amp;lt;- data.frame(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;), stringsAsFactors = FALSE)

df_02

##   x y
## 1 1 a
## 2 2 b
## 3 3 c
## 4 4 d
## 5 5 e


str(df_02)

## 'data.frame':    5 obs. of  2 variables:
##  $ x: int  1 2 3 4 5
##  $ y: chr  &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;合并 &lt;strong&gt;data frame&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;其实我们在上面介绍向量合并的时候已经接触到这个函数了，即 &lt;code&gt;cbind()&lt;/code&gt; 和 &lt;code&gt;rbind()&lt;/code&gt;。前者是按照列顺序进行合并，后者则是按照行顺序优先进行合并。
- &lt;code&gt;cbind()&lt;/code&gt;：列合并&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   df &amp;lt;- data.frame(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;))

   df

   ##   x y
   ## 1 1 a
   ## 2 2 b
   ## 3 3 c
   ## 4 4 d
   ## 5 5 e


   str(df)

   ## 'data.frame': 5 obs. of  2 variables:
   ##  $ x: int  1 2 3 4 5
   ##  $ y: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5


   df_cbind &amp;lt;- cbind(df, data.frame(z = 5:1))

   df_cbind

   ##   x y z
   ## 1 1 a 5
   ## 2 2 b 4
   ## 3 3 c 3
   ## 4 4 d 2
   ## 5 5 e 1


   str(df_cbind)

   ## 'data.frame': 5 obs. of  3 variables:
   ##  $ x: int  1 2 3 4 5
   ##  $ y: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5
   ##  $ z: int  5 4 3 2 1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;rbind()&lt;/code&gt;：行合并&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;df &amp;lt;- data.frame(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;))

df

##   x y
## 1 1 a
## 2 2 b
## 3 3 c
## 4 4 d
## 5 5 e


str(df)

## 'data.frame':  5 obs. of  2 variables:
##  $ x: int  1 2 3 4 5
##  $ y: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5


df_rbind &amp;lt;- rbind(df, data.frame(x = 10, y = &quot;j&quot;))

df_rbind

##    x y
## 1  1 a
## 2  2 b
## 3  3 c
## 4  4 d
## 5  5 e
## 6 10 j


str(df_rbind)

## 'data.frame':  6 obs. of  2 variables:
##  $ x: num  1 2 3 4 5 10
##  $ y: Factor w/ 6 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5 6
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;提取列向量&lt;/h3&gt;

&lt;p&gt;对于一个 &lt;strong&gt;data frame&lt;/strong&gt;，里面包含了非常多的信息。有时，我们只需要提取其中的某个列向量（也就是一个变量），那么可以使用 &lt;code&gt;$&lt;/code&gt; 来实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;df &amp;lt;- data.frame(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;))

df

##   x y
## 1 1 a
## 2 2 b
## 3 3 c
## 4 4 d
## 5 5 e


df$x

## [1] 1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;
<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></description>
                <link>http://miantiao.me/data-structure.html</link>
                <guid>http://miantiao.me/data-structure.html</guid>
                <pubDate>2014-01-26 00:00:00 +0800</pubDate>
                <category>yes</category>
　             　<author>ccbikai</author>
        </item>

        <item>
                <title>Data Structure</title>
                <description>&lt;p&gt;这一章主要介绍了在 &lt;strong&gt;R&lt;/strong&gt; 中最基本的元素：数据。前段时间我在网上看到一个帖子（暂时忘记在哪里找到了），强调「data science」的重心不是在前面的那个「data」，而是后面的「science」。这是因为随着互联网的深入发展，我们现在不再是缺乏数据，反而是面临着「big data」造成的「information rich」（信息冗余）的困扰。因此，今后的数据科学应当更进一步的发展新的理论与方法来解决大数据分析。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;好了，这个扯远了。不过在 &lt;strong&gt;R&lt;/strong&gt; 中，我们最紧要的事情就是：给了一大箩筐的数据，可能是排列完整的，不过大多数情况下是混乱不堪的，要求对这些数据做统计分析与可视化工作。这个基本上是一件既头疼又心烦的苦差事。首先的任务是，先对这些数据做一定格局的处理，得到我们后续需要使用的信息变量。因此，熟练掌握处理数据的基本方法，对未来的分析至关重要。&lt;/p&gt;

&lt;h2&gt;概览&lt;/h2&gt;

&lt;p&gt;Wickham 用一张表格总结了 &lt;strong&gt;R&lt;/strong&gt; 中的数据结构&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;R's base data structures are summarised in the table below, organised by their dimensionality and whether they're homogeneous (all contents must be of the same type) or heterogeneous (the contents can be of different types):&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;    &lt;/th&gt;
&lt;th&gt; Homogeneous   &lt;/th&gt;
&lt;th&gt; Heterogeneous &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; 1d &lt;/td&gt;
&lt;td&gt; Atomic vector &lt;/td&gt;
&lt;td&gt; List          &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 2d &lt;/td&gt;
&lt;td&gt; Matrix        &lt;/td&gt;
&lt;td&gt; Data frame    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; nd &lt;/td&gt;
&lt;td&gt; Array         &lt;/td&gt;
&lt;td&gt;               &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;

&lt;p&gt;需要解释的是标量（scalar）。什么是标量呢？就是一个个单独的变量，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- 5
y &amp;lt;- &quot;scalar&quot;

x

## [1] 5

y

## [1] &quot;scalar&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;R&lt;/strong&gt; 默认地将标量识别为 1*1 的向量（vector），也就是 0-dimensional。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;这里科普一下有关 &lt;strong&gt;R&lt;/strong&gt; 中的面向对象的特征。也就是说， &lt;strong&gt;R&lt;/strong&gt; 中所有的元素都可以叫做「对象」（obgect），这不仅仅是基本的数据，如向量、data frame，还包括函数（function）、环境（environment），甚至是符号（symbols）。 &lt;strong&gt;R&lt;/strong&gt; 处理完分析后得到的就是一个对象，我们需要哪儿元素，直接提取就可以了。比如，&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    df = data.frame(x = rnorm(100, 0, 1), y = seq(from = 1, to = 100))
    result &amp;lt;- lm(y ~ x, data = df)

    result

    ## 
    ## Call:
    ## lm(formula = y ~ x, data = df)
    ## 
    ## Coefficients:
    ## (Intercept)            x  
    ##       51.01         3.01
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;&lt;p&gt;得到的结果存储在 &lt;code&gt;result&lt;/code&gt; 里，这个就是一个对象，等到我们需要使用其中的「子对象」时，再从中提取即可&lt;/p&gt;&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    result$coeff

    ## (Intercept)           x 
    ##      51.005       3.007
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;面向对象的编程能够提供非常灵活的数据处理结果，并且具有较高的程序维护性。这在 &lt;strong&gt;R&lt;/strong&gt; 得到了极大的展现。&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;str()&lt;/code&gt;：查看数据结构&lt;/h3&gt;

&lt;p&gt;查看数据类型可以使用命令 &lt;code&gt;str()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;str(df)

## 'data.frame':    100 obs. of  2 variables:
##  $ x: num  0.659 0.277 0.614 -0.655 -0.896 ...
##  $ y: int  1 2 3 4 5 6 7 8 9 10 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;向量&lt;/h2&gt;

&lt;p&gt;如上所述， &lt;strong&gt;R&lt;/strong&gt; 中主要的一维数据类型包括 &lt;code&gt;atomic vector&lt;/code&gt;（基础向量） 和 &lt;code&gt;list&lt;/code&gt;（列表），前者要求罗列其中的数据均是同属性的，比如 &lt;code&gt;logical&lt;/code&gt;，&lt;code&gt;interger&lt;/code&gt;，&lt;code&gt;double&lt;/code&gt;，和 &lt;code&gt;character&lt;/code&gt;。而后者 &lt;code&gt;list&lt;/code&gt; 则可以是多种数据类型的混合。&lt;/p&gt;

&lt;h3&gt;基础向量&lt;/h3&gt;

&lt;p&gt;基础向量是组成 &lt;strong&gt;R&lt;/strong&gt; 编程语言的基石，可以由此构成其他类型的数据结构。怎么去理解  &lt;strong&gt;R&lt;/strong&gt; 中的向量呢？&lt;/p&gt;

&lt;h4&gt;数据的向量化&lt;/h4&gt;

&lt;p&gt;其实，这个可以看作是一个研究变量的序列观测值。比如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- c(35.6, 36.1, 35.8, 37, 36.5, 37.2, 35.8)
str(x)

##  num [1:7] 35.6 36.1 35.8 37 36.5 37.2 35.8

is.vector(x)

## [1] TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个就是一个向量，可以视为一天中在七个不同时间段的气温观测。因此，我们可以利用这个向量来产生矩阵，从而实现多元变量在不同时间序列上的观测值。其实，这种数据的向量化不仅提供了对数据的直观理解，而且还能提高 &lt;strong&gt;R&lt;/strong&gt; 的运算速度，尽量避免使用循环，优化程序。这点我们在日后会继续讨论。&lt;/p&gt;

&lt;h4&gt;生成向量的方法&lt;/h4&gt;

&lt;p&gt;用于生成向量的命令主要有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;c()&lt;/code&gt;:即「concantinate」的意思，用于生成一个向量，并且可用于嵌套&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  a &amp;lt;- c(1, 2, 4, 6, 8)
  b &amp;lt;- c(1, c(2, c(4, 6.8)))  # 套嵌使用
  a == b

  ## Warning: longer object length is not a multiple of shorter object length

  ## [1]  TRUE  TRUE  TRUE FALSE FALSE


  s &amp;lt;- c(1:10)  # 一个序列。相当于 seq(from = 1, to = 10, by= 1)
  s

  ##  [1]  1  2  3  4  5  6  7  8  9 10


  int &amp;lt;- c(1L, 6L, 8L)  # 产生integer类

  log &amp;lt;- c(T, F, F, T, T)  # logical

  chr &amp;lt;- c(&quot;these&quot;, &quot;are&quot;, &quot;some&quot;, &quot;character&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;seq()&lt;/code&gt;:即「sequence」的意思，主要用于产生一个带有规律的序列&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  f &amp;lt;- seq(1:10)  # 默认的increament是1,相当于 c(1:10)
  f

  ##  [1]  1  2  3  4  5  6  7  8  9 10


  g &amp;lt;- seq(from = 1, to = 10, by = 0.5)

  g

  ##  [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5
  ## [15]  8.0  8.5  9.0  9.5 10.0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;rep()&lt;/code&gt;:即[replecate],重复某个数或者某个「序列」，可用于产生较为复杂的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  h &amp;lt;- rep(5, 10)  # 单个数字的重复
  h

  ##  [1] 5 5 5 5 5 5 5 5 5 5


  j &amp;lt;- rep(c(1:3), 3)  # 重复一个序列 c(1:3)
  j

  ## [1] 1 2 3 1 2 3 1 2 3
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;rnorm()&lt;/code&gt;:产生随机数，还有其他的分布&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  k &amp;lt;- rnorm(100)  #default：rnorm(no, mean = 0, sd = 1)

  l &amp;lt;- rnorm(100, mean = 2, sd = 5)
  plot(density(l))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &lt;img src=&quot;/cn/assets/images/r-figures/2014-01-26-data-structure/unnamed-chunk-9.png&quot; alt=&quot;plot of chunk unnamed-chunk-9&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;类型与长度&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;typeof()&lt;/code&gt; 用于查看数据类型，而 &lt;code&gt;length()&lt;/code&gt; 则用于查看向量长度：如果是一维数据，则给出长度；如果是矩阵或者 &lt;code&gt;data.frame&lt;/code&gt;，则给出 &lt;code&gt;nrow&lt;/code&gt; 与 &lt;code&gt;ncol&lt;/code&gt; 的合计。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- rnorm(100)
typeof(x)

## [1] &quot;double&quot;

length(x)

## [1] 100


y &amp;lt;- c(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;)
typeof(y)

## [1] &quot;character&quot;

length(y)

## [1] 3


z &amp;lt;- c(T, T, F)
typeof(z)

## [1] &quot;logical&quot;

length(z)

## [1] 3


w &amp;lt;- seq(from = 1, to = 10, by = 1)
typeof(w)

## [1] &quot;double&quot;

length(w)

## [1] 10


mat &amp;lt;- matrix(rnorm(20), nrow = 4, ncol = 5)
typeof(mat)

## [1] &quot;double&quot;

length(mat)

## [1] 20
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;code&gt;list&lt;/code&gt;:列表&lt;/h3&gt;

&lt;p&gt;我们已经知道，&lt;code&gt;vector&lt;/code&gt;是用于同种类型属性的数据，而&lt;code&gt;list&lt;/code&gt;则适用于不同类型的数据，可以说是各种数据的一个「大火锅」。我们使用&lt;code&gt;list()&lt;/code&gt;来生成数据，不是之前介绍的&lt;code&gt;c()&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;u &amp;lt;- list(1:3, &quot;cha&quot;, T, F, c(1, 4, 7), rep(1, 3), seq(1:5))

u

## [[1]]
## [1] 1 2 3
## 
## [[2]]
## [1] &quot;cha&quot;
## 
## [[3]]
## [1] TRUE
## 
## [[4]]
## [1] FALSE
## 
## [[5]]
## [1] 1 4 7
## 
## [[6]]
## [1] 1 1 1
## 
## [[7]]
## [1] 1 2 3 4 5

str(u)

## List of 7
##  $ : int [1:3] 1 2 3
##  $ : chr &quot;cha&quot;
##  $ : logi TRUE
##  $ : logi FALSE
##  $ : num [1:3] 1 4 7
##  $ : num [1:3] 1 1 1
##  $ : int [1:5] 1 2 3 4 5

typeof(u)

## [1] &quot;list&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，&lt;code&gt;list&lt;/code&gt;也可以跟&lt;code&gt;c()&lt;/code&gt;一样实现套嵌 (Wickham称之为[recursive])&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;v &amp;lt;- list(list(2, 4, T, &quot;nope&quot;, seq(4:8)), rep(3:4, 2), list(T, F, &quot;yes&quot;))
v

## [[1]]
## [[1]][[1]]
## [1] 2
## 
## [[1]][[2]]
## [1] 4
## 
## [[1]][[3]]
## [1] TRUE
## 
## [[1]][[4]]
## [1] &quot;nope&quot;
## 
## [[1]][[5]]
## [1] 1 2 3 4 5
## 
## 
## [[2]]
## [1] 3 4 3 4
## 
## [[3]]
## [[3]][[1]]
## [1] TRUE
## 
## [[3]][[2]]
## [1] FALSE
## 
## [[3]][[3]]
## [1] &quot;yes&quot;


str(v)

## List of 3
##  $ :List of 5
##   ..$ : num 2
##   ..$ : num 4
##   ..$ : logi TRUE
##   ..$ : chr &quot;nope&quot;
##   ..$ : int [1:5] 1 2 3 4 5
##  $ : int [1:4] 3 4 3 4
##  $ :List of 3
##   ..$ : logi TRUE
##   ..$ : logi FALSE
##   ..$ : chr &quot;yes&quot;

typeof(v)

## [1] &quot;list&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;factors:因子&lt;/h3&gt;

&lt;p&gt;因子也是一种向量类型，不过在因子里面，我们需要预先设定好水平值。换句话说，因子有两个属性特者&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;class（类型)：也就是 &lt;code&gt;factor&lt;/code&gt;，使用命令 &lt;code&gt;class()&lt;/code&gt; 来查看。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;level (层级)：表明因子有哪些不同取值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x &amp;lt;- factor(c(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;))
x

## [1] a b b a
## Levels: a b

class(x)

## [1] &quot;factor&quot;

levels(x)

## [1] &quot;a&quot; &quot;b&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;矩阵&lt;/h2&gt;

&lt;p&gt;前面我们解释过如何看待向量（vector）作为一个研究变量的观测，那么，一个有多祖向量组成的矩阵（&lt;strong&gt;Matrix&lt;/strong&gt;）就可以被视为是一个多元变量的观测。每一个列向量表示一个变量，而每一个行向量则表示一次的观测结果。这样，我们便可以将其与多元统计结合在一起理解了。&lt;/p&gt;

&lt;h3&gt;创建矩阵&lt;/h3&gt;

&lt;p&gt;由于矩阵是一个带有二维属性的数据列表，我们在创建矩阵时需要设定矩阵的行与列数目。表示矩阵列向量数据的是命令 &lt;code&gt;ncol&lt;/code&gt;, 相应的，行数目的是 &lt;code&gt;nrow&lt;/code&gt;。具体的方法有&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;预先设定好行列数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; mat01 &amp;lt;- matrix(1:10, ncol = 2, nrow = 5)

 mat01

 ##      [,1] [,2]
 ## [1,]    1    6
 ## [2,]    2    7
 ## [3,]    3    8
 ## [4,]    4    9
 ## [5,]    5   10
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用命令 &lt;code&gt;dim()&lt;/code&gt; 设置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; mat02 &amp;lt;- matrix(1:10)
 dim &amp;lt;- c(2, 5)

 mat02

 ##       [,1]
 ##  [1,]    1
 ##  [2,]    2
 ##  [3,]    3
 ##  [4,]    4
 ##  [5,]    5
 ##  [6,]    6
 ##  [7,]    7
 ##  [8,]    8
 ##  [9,]    9
 ## [10,]   10
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;矩阵的行列名称&lt;/h3&gt;

&lt;p&gt;有时候，我们需要指定矩阵当中的行列名称，就像在 &lt;strong&gt;Excel&lt;/strong&gt; 里面有表头一样。这样可以通过命令来完成&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;colnames&lt;/code&gt;：列名称。可以看作是不同的研究变量，比如在多元回归里面的不同影响因素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; mat03 &amp;lt;- matrix(1:15, ncol = 3, nrow = 5)

 mat03

 ##      [,1] [,2] [,3]
 ## [1,]    1    6   11
 ## [2,]    2    7   12
 ## [3,]    3    8   13
 ## [4,]    4    9   14
 ## [5,]    5   10   15


 colnames(mat03) &amp;lt;- c(&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;)  # 三个研究变量

 mat03

 ##      x1 x2 x3
 ## [1,]  1  6 11
 ## [2,]  2  7 12
 ## [3,]  3  8 13
 ## [4,]  4  9 14
 ## [5,]  5 10 15
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;rownams&lt;/code&gt;：行名称，算作一次的截面数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; mat04 &amp;lt;- matrix(1:15, ncol = 5, nrow = 3)

 mat04

 ##      [,1] [,2] [,3] [,4] [,5]
 ## [1,]    1    4    7   10   13
 ## [2,]    2    5    8   11   14
 ## [3,]    3    6    9   12   15


 rownames(mat04) &amp;lt;- c(&quot;obs01&quot;, &quot;obs02&quot;, &quot;obs03&quot;)

 mat04

 ##       [,1] [,2] [,3] [,4] [,5]
 ## obs01    1    4    7   10   13
 ## obs02    2    5    8   11   14
 ## obs03    3    6    9   12   15
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Data Frames：数据框&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Data Frame&lt;/strong&gt; 可以说是 &lt;strong&gt;R&lt;/strong&gt; 中最重要的数据类型了，一方面，既具有向量的特征，表示同样长度的变量数据，另一方面，还保持了 &lt;code&gt;list&lt;/code&gt; 中对不同类型数据的支持。这个也是我们做计量经济分析主要用到的数据结构。&lt;strong&gt;Data Frame&lt;/strong&gt; 在很多的方面都与 &lt;strong&gt;matrix&lt;/strong&gt; 相似，比如 &lt;code&gt;colnames&lt;/code&gt;, &lt;code&gt;dim&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;建立 dataframe&lt;/h3&gt;

&lt;p&gt;建立 &lt;strong&gt;Data Frame&lt;/strong&gt; 的命令是 &lt;code&gt;data.frame&lt;/code&gt;，要求是行数目要相同，列向量允许不同类型的数据。比如，有一个数据是这样的，第一个为姓名，第二个是性别，接着是收入，受教育年限，等等。这些都可以在 &lt;strong&gt;Data Frame&lt;/strong&gt; 共存。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;df &amp;lt;- data.frame(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;))

df

##   x y
## 1 1 a
## 2 2 b
## 3 3 c
## 4 4 d
## 5 5 e


str(df)

## 'data.frame':    5 obs. of  2 variables:
##  $ x: int  1 2 3 4 5
##  $ y: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有一点需要特别注意，&lt;strong&gt;R&lt;/strong&gt; 会默认在数据框里面将字符型（string)转化为因子（factor），如果不想要转化，可以通过参数 &lt;code&gt;stringsAsFactors = FALSE&lt;/code&gt; 来设置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;df_02 &amp;lt;- data.frame(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;), stringsAsFactors = FALSE)

df_02

##   x y
## 1 1 a
## 2 2 b
## 3 3 c
## 4 4 d
## 5 5 e


str(df_02)

## 'data.frame':    5 obs. of  2 variables:
##  $ x: int  1 2 3 4 5
##  $ y: chr  &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;合并 &lt;strong&gt;data frame&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;其实我们在上面介绍向量合并的时候已经接触到这个函数了，即 &lt;code&gt;cbind()&lt;/code&gt; 和 &lt;code&gt;rbind()&lt;/code&gt;。前者是按照列顺序进行合并，后者则是按照行顺序优先进行合并。
- &lt;code&gt;cbind()&lt;/code&gt;：列合并&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   df &amp;lt;- data.frame(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;))

   df

   ##   x y
   ## 1 1 a
   ## 2 2 b
   ## 3 3 c
   ## 4 4 d
   ## 5 5 e


   str(df)

   ## 'data.frame': 5 obs. of  2 variables:
   ##  $ x: int  1 2 3 4 5
   ##  $ y: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5


   df_cbind &amp;lt;- cbind(df, data.frame(z = 5:1))

   df_cbind

   ##   x y z
   ## 1 1 a 5
   ## 2 2 b 4
   ## 3 3 c 3
   ## 4 4 d 2
   ## 5 5 e 1


   str(df_cbind)

   ## 'data.frame': 5 obs. of  3 variables:
   ##  $ x: int  1 2 3 4 5
   ##  $ y: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5
   ##  $ z: int  5 4 3 2 1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;rbind()&lt;/code&gt;：行合并&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;df &amp;lt;- data.frame(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;))

df

##   x y
## 1 1 a
## 2 2 b
## 3 3 c
## 4 4 d
## 5 5 e


str(df)

## 'data.frame':  5 obs. of  2 variables:
##  $ x: int  1 2 3 4 5
##  $ y: Factor w/ 5 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5


df_rbind &amp;lt;- rbind(df, data.frame(x = 10, y = &quot;j&quot;))

df_rbind

##    x y
## 1  1 a
## 2  2 b
## 3  3 c
## 4  4 d
## 5  5 e
## 6 10 j


str(df_rbind)

## 'data.frame':  6 obs. of  2 variables:
##  $ x: num  1 2 3 4 5 10
##  $ y: Factor w/ 6 levels &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,..: 1 2 3 4 5 6
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;提取列向量&lt;/h3&gt;

&lt;p&gt;对于一个 &lt;strong&gt;data frame&lt;/strong&gt;，里面包含了非常多的信息。有时，我们只需要提取其中的某个列向量（也就是一个变量），那么可以使用 &lt;code&gt;$&lt;/code&gt; 来实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;df &amp;lt;- data.frame(x = 1:5, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;))

df

##   x y
## 1 1 a
## 2 2 b
## 3 3 c
## 4 4 d
## 5 5 e


df$x

## [1] 1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;
<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></description>
                <link>http://miantiao.me/data-structure.html</link>
                <guid>http://miantiao.me/data-structure.html</guid>
                <pubDate>2014-01-26 00:00:00 +0800</pubDate>
                <category>Programming</category>
　             　<author>ccbikai</author>
        </item>

        <item>
                <title>使用 Jekyll + knitr 发布博客</title>
                <description>&lt;h2&gt;我的博客之旅&lt;/h2&gt;

&lt;p&gt;这些天一直都在钻研如何在博客中加入可以执行 &lt;strong&gt;R&lt;/strong&gt; 程序代码的博客模板。我先前也有过写博客的经历，不过那时候使用的博客都是免费托管在其他的服务器中，一方面是缺乏可定制，大都是千篇一律的，无法满足「DIY」的需要，另一方面，也是主要的问题，这些博客网站很少有支持 &lt;strong&gt;LaTeX&lt;/strong&gt; 的数学输出，对于数学环境的支持不尽人意。我也就偶尔在写一些纯文字类的随想，不曾涉及专业领域的事情。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;后来我实在忍无可忍了，觉得找一个必须是支持 &lt;strong&gt;LaTeX&lt;/strong&gt; 代码的博客网站。这也就只有在 &lt;strong&gt;WordPress&lt;/strong&gt; 上了。我也尝试了使用一段时间。一开始发现还真是方便，直接使用 &lt;strong&gt;LaTeX&lt;/strong&gt; 代码产生数学编译环境，如此一来便可以在上面多说点专业领域的话了。可是，后来我发现在 &lt;strong&gt;WordPress&lt;/strong&gt; 上管理博客与修改模板是一件多么痛苦的事情，既需要更改模板，而且每次改完了发现不是自己想要的效果，又得重新再做。如此一来，光花费在博客网站的维护时间竟然占用了多数。如此不堪重负。&lt;/p&gt;

&lt;p&gt;后来我开始尝试在使用  &lt;strong&gt;R&lt;/strong&gt; 做统计分析，也陆陆续续的写了一些小程序。我的想法是，将 &lt;strong&gt;R&lt;/strong&gt; 强大的数据分析与绘图能力与 &lt;strong&gt;LaTeX&lt;/strong&gt; 超级优美的数学编辑水平结合一起，从而生成既有分析又有数据、既有文本又有图表的文档。后来发现这个想法别人早已实现，那就是 &lt;code&gt;Sweave&lt;/code&gt;，支持在 &lt;strong&gt;LaTeX&lt;/strong&gt; 使用 &lt;strong&gt;R&lt;/strong&gt; 代码 （或者倒过来说，在 &lt;strong&gt;R&lt;/strong&gt; 中使用 &lt;strong&gt;LaTeX&lt;/strong&gt; 语法），并且直接输出结果。再后来，我接着发现这个原来还有『豪华升级版』，那就是我今天要给各位介绍的 &lt;code&gt;knitr&lt;/code&gt;，一个更加强大的支持 &lt;strong&gt;LaTeX&lt;/strong&gt; 编译环境的 &lt;strong&gt;R&lt;/strong&gt; 软件包。&lt;/p&gt;

&lt;p&gt;可是，有时候我不大喜欢 &lt;strong&gt;LaTeX&lt;/strong&gt; 的一点在于，永远都需要那么复杂的插入代码环境，比如，当需要使用「强调」的时候，还得非常复杂而琐碎的键入 &lt;code&gt;\emph{}&lt;/code&gt;，这个让我实在崩溃，因为毕竟我很多时候都是在使用纯文本输入，只是少数地方使用数学公式表达。那么，我想要的就是，需要强调了，就键入 &lt;em&gt;斜体强调&lt;/em&gt;，或者 &lt;strong&gt;粗体强调&lt;/strong&gt;。如此一来，写博客就非常的轻松了。&lt;/p&gt;

&lt;p&gt;于是我在某个凌晨「毅然决然」的将博客编译语言再次转移阵地。这一次，我需要&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简单：写博客就是写博客，随心所欲，没有多余的格式。在写作过程中，我仅仅需要关心文本，专注于思想表达。&lt;/li&gt;
&lt;li&gt;支持 &lt;strong&gt;R&lt;/strong&gt; 代码，能够直接产生计算结果，插入图形。而且最好的是，别人看到这个代码还觉得不错，可以自己在电脑上重复输出结果。&lt;/li&gt;
&lt;li&gt;具有良好的定制特征，我可以根据个人偏好设置网页界面，并且需要很好的可持续维护性。&lt;/li&gt;
&lt;li&gt;最后是能够记录我在不同时间段写作的备份，方便随时「倒带」。这样我就不用担心删除当下文字段落后以后就找不回来，而且最好是告诉我具体的细节。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Github + Jekyll + knitr + Rmarkdown&lt;/h2&gt;

&lt;p&gt;我就抱着这样的「苛刻要求」去找「谷哥」。出乎意料的是，竟然如此简单的就得到需要的解决方案了：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Github + Jekyll + Rmarkdown&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;这是一个完美的方案！完全实现了我需要的多种服务：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Github&lt;/strong&gt; 用于托管代码与博客。&lt;strong&gt;Git&lt;/strong&gt; 是一款优秀的版本管理软件（VCS），由现在的 &lt;strong&gt;Linux&lt;/strong&gt; 开发团队在维护。而 &lt;strong&gt;Github&lt;/strong&gt; 就相当于一个网罗世界优秀程序员的「Facebook」，汇集了目前几乎所有的开源项目。&lt;/p&gt;

&lt;p&gt;现在，我可以通过将代码与博客托管到 &lt;strong&gt;Github&lt;/strong&gt; 上，实现版本的系统检测，方便网站运行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jekyll&lt;/strong&gt; 为我的博客网站提供了静态编译，将其打包为 &lt;em&gt;Html&lt;/em&gt; 然后发布在托管的网站上。而且 &lt;strong&gt;Jekyll&lt;/strong&gt; 提供了一系列的模板与模块，方便个人定制网站。与其他博客网站不同，经常动不动的就蹦出一个广告，&lt;strong&gt;Jekyll&lt;/strong&gt; 编制的网站上面不会有多余的信息，我只陈列需要分享的内容。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后，就是 &lt;strong&gt;knitr&lt;/strong&gt; 与 &lt;strong&gt;Rmardown&lt;/strong&gt; 可以轻松的实现博客撰写。现在，我需要做的就是使用 &lt;strong&gt;Markdown&lt;/strong&gt; 语法输入，然后在需要 &lt;strong&gt;R&lt;/strong&gt; 的地方直接插入代码即可。一篇完整的博客就是我沿着自己的想法一路写到底，中间不会有其他的打扰，不要反复的插入格式命令。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;使用 &lt;strong&gt;Rmarkdown&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;下面，我介绍一下如何实现将 &lt;strong&gt;R&lt;/strong&gt; 代码编译为网页 &lt;strong&gt;Markdown&lt;/strong&gt; 格式。由于 &lt;strong&gt;Jekyll&lt;/strong&gt; 支持将 &lt;strong&gt;Markdown&lt;/strong&gt; 编译成 &lt;strong&gt;Html&lt;/strong&gt; 网页，因此，我们就可以很方便的将 &lt;strong&gt;R&lt;/strong&gt; 文件编译成 &lt;strong&gt;Html&lt;/strong&gt; 并发布到 &lt;strong&gt;Github&lt;/strong&gt; 上面了。我主要参考了 Jason Bryer 的帖子， &lt;a href=&quot;http://jason.bryer.org/posts/2012-12-10/Markdown_Jekyll_R_for_Blogging.html&quot;&gt;&quot;Using (R) Markdown, Jekyll, &amp;amp; GitHub for a Website&quot;&lt;/a&gt;。另外，由于这个帖子生成的图片存储在同样一个文件夹下面，有时我想找某个博客的图片时，会非常的不方便。于是我对其做了一个小小的修改，将经过 &lt;strong&gt;R&lt;/strong&gt; 产生的图片放在与帖子相对应的文件夹目录下，方便查找。比如，我有一个文档，&lt;code&gt;2014-01-24-shi-yong--rmarkdown--fa-biao-bo-ke.Rmd&lt;/code&gt;，那么，图片的存放目录应该是&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-dir&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-assets&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-- images&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;---- r-figures&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;----- 2014-01-24-shi-yong--rmarkdown--fa-biao-bo-ke&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;------ fig1.png&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;建立一个 &lt;code&gt;rmarkdown.r&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;首先是在主目录(&lt;code&gt;_posts&lt;/code&gt;)下面建立一个 &lt;code&gt;rmarkdown.r&lt;/code&gt; 文件，用于执行编译功能。主要用途就是实现将当前目录下所有的带 &lt;code&gt;.Rmd&lt;/code&gt; 文件转化为 &lt;code&gt;.md&lt;/code&gt; 格式，从而可以实现发布。下面是其主要内容，也可以在&lt;a href=&quot;/cn/_post/rmarkdwn.r&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#' This R script will process all R mardown files (those with in_ext file extention,
#' .rmd by default) in the current working directory. Files with a status of
#' 'processed' will be converted to markdown (with out_ext file extention, '.markdown'
#' by default). It will change the published parameter to 'true' and change the
#' status parameter to 'publish'.
#' 
#' @param dir the directory to process R Markdown files.
#' @param images.dir the base directory where images will be generated.
#' @param images.url
#' @param out_ext the file extention to use for processed files.
#' @param in_ext the file extention of input files to process.
#' @param recursive should rmd files in subdirectories be processed.
#' @return nothing.
#' @author Jason Bryer &amp;lt;jason@bryer.org&amp;gt;
convertRMarkdown &amp;lt;- function(dir=getwd(), images.dir=dir, images.url='/cn/assets/images/',
                     out_ext='.markdown', in_ext='.rmd', recursive=FALSE) {
require(knitr, quietly=TRUE, warn.conflicts=FALSE)
files &amp;lt;- list.files(path=dir, pattern=in_ext, ignore.case=TRUE, recursive=recursive)
for(f in files) {
    message(paste(&quot;Processing &quot;, f, sep=''))
    content &amp;lt;- readLines(f)
    frontMatter &amp;lt;- which(substr(content, 1, 3) == '---')
      if(length(frontMatter) &amp;gt;= 2 &amp;amp; 1 %in% frontMatter) {
          statusLine &amp;lt;- which(substr(content, 1, 7) == 'status:')
        publishedLine &amp;lt;- which(substr(content, 1, 10) == 'published:')
        if(statusLine &amp;gt; frontMatter[1] &amp;amp; statusLine &amp;lt; frontMatter[2]) {
            status &amp;lt;- unlist(strsplit(content[statusLine], ':'))[2]
            status &amp;lt;- sub('[[:space:]]+$', '', status)
            status &amp;lt;- sub('^[[:space:]]+', '', status)
            if(tolower(status) == 'process') {
                #This is a bit of a hack but if a line has zero length (i.e. a
                #black line), it will be removed in the resulting markdown file.
                  #This will ensure that all line returns are retained.
                content[nchar(content) == 0] &amp;lt;- ' '
                message(paste('Processing ', f, sep=''))
                content[statusLine] &amp;lt;- 'status: publish'
                content[publishedLine] &amp;lt;- 'published: true'
                  outFile &amp;lt;- paste(substr(f, 1, (nchar(f)-(nchar(in_ext)))), out_ext, sep='')
                render_markdown(strict=TRUE)
                opts_knit$set(out.format='markdown')
                opts_knit$set(base.dir=images.dir)
                opts_knit$set(base.url=images.url)
                ##
                ## 产生的图片存储位置 `/assets/images/r-figures/`
                fig.path &amp;lt;- paste0(&quot;r-figures/&quot;, sub(&quot;.Rmd$&quot;, &quot;&quot;, basename(files)), &quot;/&quot;)
                opts_chunk$set(fig.path = fig.path)
                ## opts_chunk$set(fig.cap = &quot;center&quot;)  ## figure position
                render_jekyll()     
                  ##
                try(knit(text=content, output=outFile), silent=FALSE)
            } else {
                warning(paste(&quot;Not processing &quot;, f, &quot;, status is '&quot;, status, 
                            &quot;'. Set status to 'process' to convert.&quot;, sep=''))
            }
        } else {
            warning(&quot;Status not found in front matter.&quot;)
        }
    } else {
        warning(&quot;No front matter found. Will not process this file.&quot;)
    }
 }
 invisible()
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;建立可执行文本 &lt;code&gt;rmd.sh&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;这个 &lt;code&gt;rmd.sh&lt;/code&gt; 也是存放在目录 &lt;code&gt;_posts&lt;/code&gt;, 主要就是&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;识别当前的目录，并将其赋予 &lt;code&gt;dir&lt;/code&gt; 参数&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;默认在 &lt;code&gt;Terminal&lt;/code&gt; 运行 &lt;code&gt;rmakrdown.r&lt;/code&gt; 的 &lt;code&gt;convertRmarkdown&lt;/code&gt; 函数，并输出经过转化的 &lt;code&gt;.markdown&lt;/code&gt; 文件。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;文本 &lt;code&gt;rmd.sh&lt;/code&gt; 可以&lt;a href=&quot;/cn/_post/rmd.sh&quot;&gt;下载&lt;/a&gt;，里面内容是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DIR=&quot;$( cd &quot;$( dirname &quot;${BASH_SOURCE[0]}&quot; )&quot; &amp;amp;&amp;amp; pwd )&quot;
Rscript -e &quot;source('$DIR/rmarkdown.r'); convertRMarkdown(images.dir='../assets/images')&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;添加 &lt;code&gt;YAML&lt;/code&gt; 标头&lt;/h3&gt;

&lt;p&gt;最后，我们需要在 &lt;code&gt;.Rmd&lt;/code&gt; 文件标头添加以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;published: false
status: process
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是因为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt; - First, the published parameter should be set to false so that Jekyll will not attempt to process the file. The convertRMarkdown function will change this parameter to true in the resulting Markdown file. &lt;/p&gt;
  &lt;p&gt; - The second parameter, status, must be set to process for the convertRMarkdown function to convert the file. This is useful when working a draft of a document and you wish to not have the file converted. &lt;/p&gt;
&lt;/blockquote&gt;


&lt;h3&gt;&lt;strong&gt;MathJax&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;如果想要让 &lt;strong&gt;Jekyll&lt;/strong&gt; 支持数学公式，我们还需要添加插件，&lt;strong&gt;MathJax&lt;/strong&gt;，然后使用 *markdown&lt;strong&gt; 的编译设置为 &lt;/strong&gt;kramdown**。我是这样配置的&lt;/p&gt;

&lt;h4&gt;添加 &lt;strong&gt;kramdown&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;由于我先前使用的是 &lt;em&gt;rdiscount&lt;/em&gt; 来编译 &lt;strong&gt;mardown&lt;/strong&gt; 语法，不能够支持对数学公式的输出。使用的替代是 &lt;strong&gt;kramdown&lt;/strong&gt;，一个更加强大的插件，支持 &lt;em&gt;pdf&lt;/em&gt;， &lt;em&gt;html&lt;/em&gt;，&lt;em&gt;LaTeX&lt;/em&gt; 等格式的转化。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先是在主目录文件夹找到 &lt;code&gt;_config-yml&lt;/code&gt; 打开，将 &lt;strong&gt;markdown&lt;/strong&gt; 默认的编译设置为 &lt;strong&gt;kramdown&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 &lt;code&gt;_layout&lt;/code&gt; 目录下面有 &lt;code&gt;post.html&lt;/code&gt; 的页面设置，我们需要在 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 与 &lt;code&gt;&amp;lt;/head&amp;gt;&lt;/code&gt; 之间插入代码
&lt;img src=&quot;/cn/assets/images/r-figures/2014-01-24-shi-yong--rmarkdown--fa-biao-bo-ke/snapshot1.png&quot; alt=&quot;snapshot1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt; 也就是在网页开启前使用 &lt;strong&gt;MathJax&lt;/strong&gt; 进行编译，支持对数学的输出。这里，我使用单个美元符号 &lt;code&gt;$&lt;/code&gt; 与 &lt;code&gt;$&lt;/code&gt; 输入 &lt;strong&gt;LaTeX&lt;/strong&gt; 代码，会在网页显示相应的 &lt;em&gt;行内公式&lt;/em&gt;，而使用一对的美元符号 &lt;code&gt;$$&lt;/code&gt; 与 &lt;code&gt;$$&lt;/code&gt; 来输入行间数学公式。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;例子&lt;/h3&gt;

&lt;h4&gt;数学公式&lt;/h4&gt;

&lt;p&gt;比如我只需要如下输入数学公式，$S = \sum_{i=1}^k x_i$，或者是$$a&lt;sup&gt;2&lt;/sup&gt; + b&lt;sup&gt;2&lt;/sup&gt; = c&lt;sup&gt;2&lt;/sup&gt;$$&lt;/p&gt;

&lt;p&gt;$$\frac{1}{\pi}=\frac{2\sqrt{2}}{9801}\sum_{k=0}^\infty\frac{(4k)!(1103+26390k)}{(k!)&lt;sup&gt;4396&lt;/sup&gt;^{4k}}$$&lt;/p&gt;

&lt;p&gt;$$ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} = 1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}} {1+\frac{e^{-8\pi}} {1+\ldots} } } } $$&lt;/p&gt;

&lt;p&gt;$$
\begin{align}
\mbox{Union: } &amp;amp; A\cup B = {x\mid x\in A \mbox{ or } x\in B} \
\mbox{Concatenation: } &amp;amp; A\circ B  = {xy\mid x\in A \mbox{ and } y\in B} \
\mbox{Star: } &amp;amp; A^\star  = {x_1x_2\ldots x_k \mid  k\geq 0 \mbox{ and each } x_i\in A} \
\end{align}
$$&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;R&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;再者，这个 &lt;code&gt;R&lt;/code&gt; 代码，我们可以直接生成图片。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = rnorm(100)
plot(density(x))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/cn/assets/images/r-figures/2014-01-24-shi-yong--rmarkdown--fa-biao-bo-ke/fig1.png&quot; alt=&quot;plot of chunk fig1&quot; /&gt;&lt;/p&gt;
<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></description>
                <link>http://miantiao.me/shi-yong--rmarkdown--fa-biao-bo-ke.html</link>
                <guid>http://miantiao.me/shi-yong--rmarkdown--fa-biao-bo-ke.html</guid>
                <pubDate>2014-01-24 00:00:00 +0800</pubDate>
                <category>yes</category>
　             　<author>ccbikai</author>
        </item>

        <item>
                <title>使用 Jekyll + knitr 发布博客</title>
                <description>&lt;h2&gt;我的博客之旅&lt;/h2&gt;

&lt;p&gt;这些天一直都在钻研如何在博客中加入可以执行 &lt;strong&gt;R&lt;/strong&gt; 程序代码的博客模板。我先前也有过写博客的经历，不过那时候使用的博客都是免费托管在其他的服务器中，一方面是缺乏可定制，大都是千篇一律的，无法满足「DIY」的需要，另一方面，也是主要的问题，这些博客网站很少有支持 &lt;strong&gt;LaTeX&lt;/strong&gt; 的数学输出，对于数学环境的支持不尽人意。我也就偶尔在写一些纯文字类的随想，不曾涉及专业领域的事情。&lt;/p&gt;

&lt;!-- more --&gt;


&lt;p&gt;后来我实在忍无可忍了，觉得找一个必须是支持 &lt;strong&gt;LaTeX&lt;/strong&gt; 代码的博客网站。这也就只有在 &lt;strong&gt;WordPress&lt;/strong&gt; 上了。我也尝试了使用一段时间。一开始发现还真是方便，直接使用 &lt;strong&gt;LaTeX&lt;/strong&gt; 代码产生数学编译环境，如此一来便可以在上面多说点专业领域的话了。可是，后来我发现在 &lt;strong&gt;WordPress&lt;/strong&gt; 上管理博客与修改模板是一件多么痛苦的事情，既需要更改模板，而且每次改完了发现不是自己想要的效果，又得重新再做。如此一来，光花费在博客网站的维护时间竟然占用了多数。如此不堪重负。&lt;/p&gt;

&lt;p&gt;后来我开始尝试在使用  &lt;strong&gt;R&lt;/strong&gt; 做统计分析，也陆陆续续的写了一些小程序。我的想法是，将 &lt;strong&gt;R&lt;/strong&gt; 强大的数据分析与绘图能力与 &lt;strong&gt;LaTeX&lt;/strong&gt; 超级优美的数学编辑水平结合一起，从而生成既有分析又有数据、既有文本又有图表的文档。后来发现这个想法别人早已实现，那就是 &lt;code&gt;Sweave&lt;/code&gt;，支持在 &lt;strong&gt;LaTeX&lt;/strong&gt; 使用 &lt;strong&gt;R&lt;/strong&gt; 代码 （或者倒过来说，在 &lt;strong&gt;R&lt;/strong&gt; 中使用 &lt;strong&gt;LaTeX&lt;/strong&gt; 语法），并且直接输出结果。再后来，我接着发现这个原来还有『豪华升级版』，那就是我今天要给各位介绍的 &lt;code&gt;knitr&lt;/code&gt;，一个更加强大的支持 &lt;strong&gt;LaTeX&lt;/strong&gt; 编译环境的 &lt;strong&gt;R&lt;/strong&gt; 软件包。&lt;/p&gt;

&lt;p&gt;可是，有时候我不大喜欢 &lt;strong&gt;LaTeX&lt;/strong&gt; 的一点在于，永远都需要那么复杂的插入代码环境，比如，当需要使用「强调」的时候，还得非常复杂而琐碎的键入 &lt;code&gt;\emph{}&lt;/code&gt;，这个让我实在崩溃，因为毕竟我很多时候都是在使用纯文本输入，只是少数地方使用数学公式表达。那么，我想要的就是，需要强调了，就键入 &lt;em&gt;斜体强调&lt;/em&gt;，或者 &lt;strong&gt;粗体强调&lt;/strong&gt;。如此一来，写博客就非常的轻松了。&lt;/p&gt;

&lt;p&gt;于是我在某个凌晨「毅然决然」的将博客编译语言再次转移阵地。这一次，我需要&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简单：写博客就是写博客，随心所欲，没有多余的格式。在写作过程中，我仅仅需要关心文本，专注于思想表达。&lt;/li&gt;
&lt;li&gt;支持 &lt;strong&gt;R&lt;/strong&gt; 代码，能够直接产生计算结果，插入图形。而且最好的是，别人看到这个代码还觉得不错，可以自己在电脑上重复输出结果。&lt;/li&gt;
&lt;li&gt;具有良好的定制特征，我可以根据个人偏好设置网页界面，并且需要很好的可持续维护性。&lt;/li&gt;
&lt;li&gt;最后是能够记录我在不同时间段写作的备份，方便随时「倒带」。这样我就不用担心删除当下文字段落后以后就找不回来，而且最好是告诉我具体的细节。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Github + Jekyll + knitr + Rmarkdown&lt;/h2&gt;

&lt;p&gt;我就抱着这样的「苛刻要求」去找「谷哥」。出乎意料的是，竟然如此简单的就得到需要的解决方案了：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Github + Jekyll + Rmarkdown&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;这是一个完美的方案！完全实现了我需要的多种服务：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Github&lt;/strong&gt; 用于托管代码与博客。&lt;strong&gt;Git&lt;/strong&gt; 是一款优秀的版本管理软件（VCS），由现在的 &lt;strong&gt;Linux&lt;/strong&gt; 开发团队在维护。而 &lt;strong&gt;Github&lt;/strong&gt; 就相当于一个网罗世界优秀程序员的「Facebook」，汇集了目前几乎所有的开源项目。&lt;/p&gt;

&lt;p&gt;现在，我可以通过将代码与博客托管到 &lt;strong&gt;Github&lt;/strong&gt; 上，实现版本的系统检测，方便网站运行。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jekyll&lt;/strong&gt; 为我的博客网站提供了静态编译，将其打包为 &lt;em&gt;Html&lt;/em&gt; 然后发布在托管的网站上。而且 &lt;strong&gt;Jekyll&lt;/strong&gt; 提供了一系列的模板与模块，方便个人定制网站。与其他博客网站不同，经常动不动的就蹦出一个广告，&lt;strong&gt;Jekyll&lt;/strong&gt; 编制的网站上面不会有多余的信息，我只陈列需要分享的内容。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后，就是 &lt;strong&gt;knitr&lt;/strong&gt; 与 &lt;strong&gt;Rmardown&lt;/strong&gt; 可以轻松的实现博客撰写。现在，我需要做的就是使用 &lt;strong&gt;Markdown&lt;/strong&gt; 语法输入，然后在需要 &lt;strong&gt;R&lt;/strong&gt; 的地方直接插入代码即可。一篇完整的博客就是我沿着自己的想法一路写到底，中间不会有其他的打扰，不要反复的插入格式命令。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;使用 &lt;strong&gt;Rmarkdown&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;下面，我介绍一下如何实现将 &lt;strong&gt;R&lt;/strong&gt; 代码编译为网页 &lt;strong&gt;Markdown&lt;/strong&gt; 格式。由于 &lt;strong&gt;Jekyll&lt;/strong&gt; 支持将 &lt;strong&gt;Markdown&lt;/strong&gt; 编译成 &lt;strong&gt;Html&lt;/strong&gt; 网页，因此，我们就可以很方便的将 &lt;strong&gt;R&lt;/strong&gt; 文件编译成 &lt;strong&gt;Html&lt;/strong&gt; 并发布到 &lt;strong&gt;Github&lt;/strong&gt; 上面了。我主要参考了 Jason Bryer 的帖子， &lt;a href=&quot;http://jason.bryer.org/posts/2012-12-10/Markdown_Jekyll_R_for_Blogging.html&quot;&gt;&quot;Using (R) Markdown, Jekyll, &amp;amp; GitHub for a Website&quot;&lt;/a&gt;。另外，由于这个帖子生成的图片存储在同样一个文件夹下面，有时我想找某个博客的图片时，会非常的不方便。于是我对其做了一个小小的修改，将经过 &lt;strong&gt;R&lt;/strong&gt; 产生的图片放在与帖子相对应的文件夹目录下，方便查找。比如，我有一个文档，&lt;code&gt;2014-01-24-shi-yong--rmarkdown--fa-biao-bo-ke.Rmd&lt;/code&gt;，那么，图片的存放目录应该是&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-dir&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-assets&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-- images&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;---- r-figures&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;----- 2014-01-24-shi-yong--rmarkdown--fa-biao-bo-ke&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;------ fig1.png&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;建立一个 &lt;code&gt;rmarkdown.r&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;首先是在主目录(&lt;code&gt;_posts&lt;/code&gt;)下面建立一个 &lt;code&gt;rmarkdown.r&lt;/code&gt; 文件，用于执行编译功能。主要用途就是实现将当前目录下所有的带 &lt;code&gt;.Rmd&lt;/code&gt; 文件转化为 &lt;code&gt;.md&lt;/code&gt; 格式，从而可以实现发布。下面是其主要内容，也可以在&lt;a href=&quot;/cn/_post/rmarkdwn.r&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#' This R script will process all R mardown files (those with in_ext file extention,
#' .rmd by default) in the current working directory. Files with a status of
#' 'processed' will be converted to markdown (with out_ext file extention, '.markdown'
#' by default). It will change the published parameter to 'true' and change the
#' status parameter to 'publish'.
#' 
#' @param dir the directory to process R Markdown files.
#' @param images.dir the base directory where images will be generated.
#' @param images.url
#' @param out_ext the file extention to use for processed files.
#' @param in_ext the file extention of input files to process.
#' @param recursive should rmd files in subdirectories be processed.
#' @return nothing.
#' @author Jason Bryer &amp;lt;jason@bryer.org&amp;gt;
convertRMarkdown &amp;lt;- function(dir=getwd(), images.dir=dir, images.url='/cn/assets/images/',
                     out_ext='.markdown', in_ext='.rmd', recursive=FALSE) {
require(knitr, quietly=TRUE, warn.conflicts=FALSE)
files &amp;lt;- list.files(path=dir, pattern=in_ext, ignore.case=TRUE, recursive=recursive)
for(f in files) {
    message(paste(&quot;Processing &quot;, f, sep=''))
    content &amp;lt;- readLines(f)
    frontMatter &amp;lt;- which(substr(content, 1, 3) == '---')
      if(length(frontMatter) &amp;gt;= 2 &amp;amp; 1 %in% frontMatter) {
          statusLine &amp;lt;- which(substr(content, 1, 7) == 'status:')
        publishedLine &amp;lt;- which(substr(content, 1, 10) == 'published:')
        if(statusLine &amp;gt; frontMatter[1] &amp;amp; statusLine &amp;lt; frontMatter[2]) {
            status &amp;lt;- unlist(strsplit(content[statusLine], ':'))[2]
            status &amp;lt;- sub('[[:space:]]+$', '', status)
            status &amp;lt;- sub('^[[:space:]]+', '', status)
            if(tolower(status) == 'process') {
                #This is a bit of a hack but if a line has zero length (i.e. a
                #black line), it will be removed in the resulting markdown file.
                  #This will ensure that all line returns are retained.
                content[nchar(content) == 0] &amp;lt;- ' '
                message(paste('Processing ', f, sep=''))
                content[statusLine] &amp;lt;- 'status: publish'
                content[publishedLine] &amp;lt;- 'published: true'
                  outFile &amp;lt;- paste(substr(f, 1, (nchar(f)-(nchar(in_ext)))), out_ext, sep='')
                render_markdown(strict=TRUE)
                opts_knit$set(out.format='markdown')
                opts_knit$set(base.dir=images.dir)
                opts_knit$set(base.url=images.url)
                ##
                ## 产生的图片存储位置 `/assets/images/r-figures/`
                fig.path &amp;lt;- paste0(&quot;r-figures/&quot;, sub(&quot;.Rmd$&quot;, &quot;&quot;, basename(files)), &quot;/&quot;)
                opts_chunk$set(fig.path = fig.path)
                ## opts_chunk$set(fig.cap = &quot;center&quot;)  ## figure position
                render_jekyll()     
                  ##
                try(knit(text=content, output=outFile), silent=FALSE)
            } else {
                warning(paste(&quot;Not processing &quot;, f, &quot;, status is '&quot;, status, 
                            &quot;'. Set status to 'process' to convert.&quot;, sep=''))
            }
        } else {
            warning(&quot;Status not found in front matter.&quot;)
        }
    } else {
        warning(&quot;No front matter found. Will not process this file.&quot;)
    }
 }
 invisible()
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;建立可执行文本 &lt;code&gt;rmd.sh&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;这个 &lt;code&gt;rmd.sh&lt;/code&gt; 也是存放在目录 &lt;code&gt;_posts&lt;/code&gt;, 主要就是&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;识别当前的目录，并将其赋予 &lt;code&gt;dir&lt;/code&gt; 参数&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;默认在 &lt;code&gt;Terminal&lt;/code&gt; 运行 &lt;code&gt;rmakrdown.r&lt;/code&gt; 的 &lt;code&gt;convertRmarkdown&lt;/code&gt; 函数，并输出经过转化的 &lt;code&gt;.markdown&lt;/code&gt; 文件。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;文本 &lt;code&gt;rmd.sh&lt;/code&gt; 可以&lt;a href=&quot;/cn/_post/rmd.sh&quot;&gt;下载&lt;/a&gt;，里面内容是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DIR=&quot;$( cd &quot;$( dirname &quot;${BASH_SOURCE[0]}&quot; )&quot; &amp;amp;&amp;amp; pwd )&quot;
Rscript -e &quot;source('$DIR/rmarkdown.r'); convertRMarkdown(images.dir='../assets/images')&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;添加 &lt;code&gt;YAML&lt;/code&gt; 标头&lt;/h3&gt;

&lt;p&gt;最后，我们需要在 &lt;code&gt;.Rmd&lt;/code&gt; 文件标头添加以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;published: false
status: process
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是因为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt; - First, the published parameter should be set to false so that Jekyll will not attempt to process the file. The convertRMarkdown function will change this parameter to true in the resulting Markdown file. &lt;/p&gt;
  &lt;p&gt; - The second parameter, status, must be set to process for the convertRMarkdown function to convert the file. This is useful when working a draft of a document and you wish to not have the file converted. &lt;/p&gt;
&lt;/blockquote&gt;


&lt;h3&gt;&lt;strong&gt;MathJax&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;如果想要让 &lt;strong&gt;Jekyll&lt;/strong&gt; 支持数学公式，我们还需要添加插件，&lt;strong&gt;MathJax&lt;/strong&gt;，然后使用 *markdown&lt;strong&gt; 的编译设置为 &lt;/strong&gt;kramdown**。我是这样配置的&lt;/p&gt;

&lt;h4&gt;添加 &lt;strong&gt;kramdown&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;由于我先前使用的是 &lt;em&gt;rdiscount&lt;/em&gt; 来编译 &lt;strong&gt;mardown&lt;/strong&gt; 语法，不能够支持对数学公式的输出。使用的替代是 &lt;strong&gt;kramdown&lt;/strong&gt;，一个更加强大的插件，支持 &lt;em&gt;pdf&lt;/em&gt;， &lt;em&gt;html&lt;/em&gt;，&lt;em&gt;LaTeX&lt;/em&gt; 等格式的转化。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先是在主目录文件夹找到 &lt;code&gt;_config-yml&lt;/code&gt; 打开，将 &lt;strong&gt;markdown&lt;/strong&gt; 默认的编译设置为 &lt;strong&gt;kramdown&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 &lt;code&gt;_layout&lt;/code&gt; 目录下面有 &lt;code&gt;post.html&lt;/code&gt; 的页面设置，我们需要在 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 与 &lt;code&gt;&amp;lt;/head&amp;gt;&lt;/code&gt; 之间插入代码
&lt;img src=&quot;/cn/assets/images/r-figures/2014-01-24-shi-yong--rmarkdown--fa-biao-bo-ke/snapshot1.png&quot; alt=&quot;snapshot1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt; 也就是在网页开启前使用 &lt;strong&gt;MathJax&lt;/strong&gt; 进行编译，支持对数学的输出。这里，我使用单个美元符号 &lt;code&gt;$&lt;/code&gt; 与 &lt;code&gt;$&lt;/code&gt; 输入 &lt;strong&gt;LaTeX&lt;/strong&gt; 代码，会在网页显示相应的 &lt;em&gt;行内公式&lt;/em&gt;，而使用一对的美元符号 &lt;code&gt;$$&lt;/code&gt; 与 &lt;code&gt;$$&lt;/code&gt; 来输入行间数学公式。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;例子&lt;/h3&gt;

&lt;h4&gt;数学公式&lt;/h4&gt;

&lt;p&gt;比如我只需要如下输入数学公式，$S = \sum_{i=1}^k x_i$，或者是$$a&lt;sup&gt;2&lt;/sup&gt; + b&lt;sup&gt;2&lt;/sup&gt; = c&lt;sup&gt;2&lt;/sup&gt;$$&lt;/p&gt;

&lt;p&gt;$$\frac{1}{\pi}=\frac{2\sqrt{2}}{9801}\sum_{k=0}^\infty\frac{(4k)!(1103+26390k)}{(k!)&lt;sup&gt;4396&lt;/sup&gt;^{4k}}$$&lt;/p&gt;

&lt;p&gt;$$ \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} = 1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}} {1+\frac{e^{-8\pi}} {1+\ldots} } } } $$&lt;/p&gt;

&lt;p&gt;$$
\begin{align}
\mbox{Union: } &amp;amp; A\cup B = {x\mid x\in A \mbox{ or } x\in B} \
\mbox{Concatenation: } &amp;amp; A\circ B  = {xy\mid x\in A \mbox{ and } y\in B} \
\mbox{Star: } &amp;amp; A^\star  = {x_1x_2\ldots x_k \mid  k\geq 0 \mbox{ and each } x_i\in A} \
\end{align}
$$&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;R&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;再者，这个 &lt;code&gt;R&lt;/code&gt; 代码，我们可以直接生成图片。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = rnorm(100)
plot(density(x))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/cn/assets/images/r-figures/2014-01-24-shi-yong--rmarkdown--fa-biao-bo-ke/fig1.png&quot; alt=&quot;plot of chunk fig1&quot; /&gt;&lt;/p&gt;
<img src="http://img.tongji.linezing.com/3379661/tongji.gif" border="0" /></description>
                <link>http://miantiao.me/shi-yong--rmarkdown--fa-biao-bo-ke.html</link>
                <guid>http://miantiao.me/shi-yong--rmarkdown--fa-biao-bo-ke.html</guid>
                <pubDate>2014-01-24 00:00:00 +0800</pubDate>
                <category>Tech</category>
　             　<author>ccbikai</author>
        </item>


</channel>
</rss>
